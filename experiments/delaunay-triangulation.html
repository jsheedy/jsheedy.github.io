<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Delaunay Triangulation</title>
	<style>
		* { box-sizing: border-box; margin: 0; padding: 0; }
		html, body { height: 100%; overflow: hidden; }
		body {
			font-family: 'Segoe UI', system-ui, sans-serif;
			background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
			color: #e8e8e8;
			display: flex;
			flex-direction: column;
		}

		.title-bar {
			background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
			border-bottom: 1px solid rgba(255,255,255,0.15);
			padding: 15px 20px;
			text-align: center;
			backdrop-filter: blur(10px);
			position: relative;
		}

		.back-link {
			position: absolute;
			left: 20px;
			top: 50%;
			transform: translateY(-50%);
			color: #e8e8e8;
			text-decoration: none;
			font-size: 13px;
			padding: 8px 15px;
			border: 1px solid rgba(255,255,255,0.3);
			background: rgba(255,255,255,0.1);
			border-radius: 6px;
			transition: all 0.2s;
		}

		.back-link:hover {
			background: rgba(255,255,255,0.2);
			border-color: rgba(255,255,255,0.5);
		}

		.back-link::before { content: "← "; }

		.title-text {
			font-size: 28px;
			font-weight: 600;
			letter-spacing: 3px;
			background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			text-transform: uppercase;
		}

		.title-subtitle {
			font-size: 12px;
			letter-spacing: 2px;
			color: rgba(255,255,255,0.6);
			margin-top: 4px;
		}

		.controls {
			background: rgba(0,0,0,0.3);
			border-bottom: 1px solid rgba(255,255,255,0.1);
			padding: 12px 20px;
			display: flex;
			flex-wrap: wrap;
			gap: 16px;
			align-items: center;
			font-size: 13px;
		}

		.control-group {
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.control-divider {
			width: 1px;
			height: 24px;
			background: rgba(255,255,255,0.2);
		}

		button {
			background: rgba(255,255,255,0.1);
			color: #e8e8e8;
			border: 1px solid rgba(255,255,255,0.3);
			padding: 6px 14px;
			font-family: inherit;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.15s;
			border-radius: 6px;
		}

		button:hover {
			background: rgba(255,255,255,0.2);
			border-color: rgba(255,255,255,0.5);
		}

		button:active { transform: scale(0.97); }

		button.active {
			background: rgba(72, 219, 251, 0.3);
			border-color: #48dbfb;
		}

		label {
			display: flex;
			align-items: center;
			gap: 6px;
			cursor: pointer;
			user-select: none;
			font-size: 12px;
		}

		input[type="checkbox"] {
			width: 16px;
			height: 16px;
			cursor: pointer;
			accent-color: #48dbfb;
		}

		input[type="number"], select {
			background: rgba(0,0,0,0.3);
			color: #e8e8e8;
			border: 1px solid rgba(255,255,255,0.2);
			padding: 5px 8px;
			font-family: inherit;
			font-size: 12px;
			width: 65px;
			border-radius: 4px;
		}

		select { width: auto; cursor: pointer; }

		input[type="number"]:focus, select:focus {
			outline: none;
			border-color: #48dbfb;
		}

		.canvas-container {
			flex: 1;
			position: relative;
			overflow: hidden;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
			cursor: crosshair;
		}

		.stats {
			position: absolute;
			top: 12px;
			right: 12px;
			background: rgba(0,0,0,0.7);
			border: 1px solid rgba(255,255,255,0.15);
			padding: 12px 16px;
			font-size: 12px;
			line-height: 1.8;
			border-radius: 8px;
			backdrop-filter: blur(10px);
			min-width: 160px;
		}

		.stats div {
			display: flex;
			justify-content: space-between;
			gap: 16px;
		}

		.stats .label { color: rgba(255,255,255,0.6); }
		.stats .value { color: #48dbfb; font-weight: 600; }
		.stats .good { color: #1dd1a1; }
		.stats .warn { color: #feca57; }
		.stats .bad { color: #ff6b6b; }

		.instructions {
			position: absolute;
			bottom: 12px;
			left: 12px;
			background: rgba(0,0,0,0.7);
			border: 1px solid rgba(255,255,255,0.15);
			padding: 10px 14px;
			font-size: 11px;
			line-height: 1.6;
			border-radius: 8px;
			backdrop-filter: blur(10px);
		}

		.instructions div { color: rgba(255,255,255,0.7); }
		.instructions kbd {
			background: rgba(255,255,255,0.15);
			padding: 2px 6px;
			border-radius: 3px;
			font-family: inherit;
		}

		.animation-controls {
			position: absolute;
			bottom: 12px;
			right: 12px;
			background: rgba(0,0,0,0.7);
			border: 1px solid rgba(255,255,255,0.15);
			padding: 10px 14px;
			font-size: 12px;
			border-radius: 8px;
			backdrop-filter: blur(10px);
			display: none;
		}

		.animation-controls.visible { display: flex; gap: 8px; align-items: center; }

		.speed-slider {
			width: 80px;
			accent-color: #48dbfb;
		}
	</style>
</head>
<body>
	<div class="title-bar">
		<a href="index.html" class="back-link">Experiments</a>
		<div class="title-text">Delaunay Triangulation</div>
		<div class="title-subtitle">Interactive Bowyer-Watson algorithm visualization</div>
	</div>

	<div class="controls">
		<div class="control-group">
			<button id="btnClear">Clear</button>
			<button id="btnRandom">Random</button>
			<input type="number" id="numRandom" min="3" max="500" value="30" step="5">
		</div>

		<div class="control-divider"></div>

		<div class="control-group">
			<label><input type="checkbox" id="chkTriangles" checked> Triangles</label>
			<label><input type="checkbox" id="chkEdges" checked> Edges</label>
			<label><input type="checkbox" id="chkPoints" checked> Points</label>
		</div>

		<div class="control-divider"></div>

		<div class="control-group">
			<label><input type="checkbox" id="chkCircumcircles"> Circumcircles</label>
			<label><input type="checkbox" id="chkVoronoi"> Voronoi Dual</label>
		</div>

		<div class="control-divider"></div>

		<div class="control-group">
			<label>Color by:</label>
			<select id="colorMode">
				<option value="gradient">Gradient</option>
				<option value="area">Area</option>
				<option value="angle">Min Angle</option>
				<option value="aspect">Aspect Ratio</option>
			</select>
		</div>

		<div class="control-divider"></div>

		<div class="control-group">
			<button id="btnAnimate">Animate Build</button>
		</div>
	</div>

	<div class="canvas-container">
		<canvas id="canvas"></canvas>

		<div class="stats">
			<div><span class="label">Points:</span><span class="value" id="statPoints">0</span></div>
			<div><span class="label">Triangles:</span><span class="value" id="statTriangles">0</span></div>
			<div><span class="label">Edges:</span><span class="value" id="statEdges">0</span></div>
			<div><span class="label">Min Angle:</span><span class="value" id="statMinAngle">--</span></div>
			<div><span class="label">Avg Aspect:</span><span class="value" id="statAspect">--</span></div>
		</div>

		<div class="instructions">
			<div><kbd>Click</kbd> Add point &bull; <kbd>Drag</kbd> Move point &bull; <kbd>Right-click</kbd> Delete</div>
		</div>

		<div class="animation-controls" id="animControls">
			<span>Speed:</span>
			<input type="range" class="speed-slider" id="animSpeed" min="1" max="10" value="5">
			<button id="btnStopAnim">Stop</button>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');

		// State
		let points = [];
		let triangulation = null;
		let draggedPoint = null;
		let hoveredPoint = null;

		// Display options
		let showTriangles = true;
		let showEdges = true;
		let showPoints = true;
		let showCircumcircles = false;
		let showVoronoi = false;
		let colorMode = 'gradient';

		// Animation state
		let isAnimating = false;
		let animationPoints = [];
		let animationIndex = 0;
		let animationSpeed = 5;

		// Color palettes
		const gradientColors = [
			'#ff6b6b', '#ff8e72', '#feca57', '#48dbfb',
			'#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3'
		];

		// Resize canvas
		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			const dpr = window.devicePixelRatio || 1;
			canvas.width = rect.width * dpr;
			canvas.height = rect.height * dpr;
			ctx.scale(dpr, dpr);
			canvas.style.width = rect.width + 'px';
			canvas.style.height = rect.height + 'px';
			render();
		}
		window.addEventListener('resize', resizeCanvas);

		// Delaunay Triangulation using Bowyer-Watson algorithm
		class DelaunayTriangulation {
			constructor(pts, width, height) {
				this.points = pts;
				this.triangles = [];
				this.width = width;
				this.height = height;

				if (pts.length < 3) return;

				// Create super-triangle encompassing all points
				const margin = Math.max(width, height) * 10;
				this.superTriangle = [
					{ x: -margin, y: -margin, isSuper: true },
					{ x: width + margin, y: -margin, isSuper: true },
					{ x: width / 2, y: height + margin, isSuper: true }
				];

				this.triangles.push({
					vertices: [...this.superTriangle],
					circumcircle: this.calcCircumcircle(this.superTriangle)
				});

				// Add each point incrementally
				for (const point of pts) {
					this.addPoint(point);
				}

				// Remove triangles connected to super-triangle
				this.triangles = this.triangles.filter(tri =>
					!tri.vertices.some(v => v.isSuper)
				);
			}

			addPoint(point) {
				const badTriangles = [];

				// Find triangles whose circumcircle contains the point
				for (const tri of this.triangles) {
					if (this.pointInCircumcircle(point, tri.circumcircle)) {
						badTriangles.push(tri);
					}
				}

				// Find boundary polygon (edges not shared by bad triangles)
				const polygon = [];
				for (const tri of badTriangles) {
					for (let i = 0; i < 3; i++) {
						const edge = [tri.vertices[i], tri.vertices[(i + 1) % 3]];
						let isShared = false;

						for (const other of badTriangles) {
							if (other === tri) continue;
							for (let j = 0; j < 3; j++) {
								const otherEdge = [other.vertices[j], other.vertices[(j + 1) % 3]];
								if (this.edgesEqual(edge, otherEdge)) {
									isShared = true;
									break;
								}
							}
							if (isShared) break;
						}

						if (!isShared) polygon.push(edge);
					}
				}

				// Remove bad triangles
				this.triangles = this.triangles.filter(tri => !badTriangles.includes(tri));

				// Create new triangles from point to polygon edges
				for (const edge of polygon) {
					const vertices = [edge[0], edge[1], point];
					this.triangles.push({
						vertices,
						circumcircle: this.calcCircumcircle(vertices)
					});
				}
			}

			calcCircumcircle(vertices) {
				const [a, b, c] = vertices;
				const d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));

				if (Math.abs(d) < 1e-10) {
					return { x: 0, y: 0, r: Infinity };
				}

				const ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) +
				           (b.x * b.x + b.y * b.y) * (c.y - a.y) +
				           (c.x * c.x + c.y * c.y) * (a.y - b.y)) / d;
				const uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) +
				           (b.x * b.x + b.y * b.y) * (a.x - c.x) +
				           (c.x * c.x + c.y * c.y) * (b.x - a.x)) / d;
				const r = Math.sqrt((a.x - ux) ** 2 + (a.y - uy) ** 2);

				return { x: ux, y: uy, r };
			}

			pointInCircumcircle(point, circle) {
				if (circle.r === Infinity) return false;
				const dx = point.x - circle.x;
				const dy = point.y - circle.y;
				return dx * dx + dy * dy <= circle.r * circle.r;
			}

			edgesEqual(e1, e2) {
				return (e1[0] === e2[0] && e1[1] === e2[1]) ||
				       (e1[0] === e2[1] && e1[1] === e2[0]);
			}

			getEdges() {
				const edges = new Set();
				for (const tri of this.triangles) {
					for (let i = 0; i < 3; i++) {
						const a = tri.vertices[i];
						const b = tri.vertices[(i + 1) % 3];
						const key = a.x < b.x || (a.x === b.x && a.y < b.y)
							? `${a.x},${a.y}-${b.x},${b.y}`
							: `${b.x},${b.y}-${a.x},${a.y}`;
						edges.add(key);
					}
				}
				return edges.size;
			}

			// Compute Voronoi diagram (dual of Delaunay)
			getVoronoiEdges() {
				const voronoiEdges = [];

				for (let i = 0; i < this.triangles.length; i++) {
					const tri = this.triangles[i];
					const c1 = tri.circumcircle;
					if (c1.r === Infinity) continue;

					// Find adjacent triangles (share 2 vertices)
					for (let j = i + 1; j < this.triangles.length; j++) {
						const other = this.triangles[j];
						const c2 = other.circumcircle;
						if (c2.r === Infinity) continue;

						let shared = 0;
						for (const v1 of tri.vertices) {
							for (const v2 of other.vertices) {
								if (v1 === v2) shared++;
							}
						}

						if (shared === 2) {
							voronoiEdges.push([
								{ x: c1.x, y: c1.y },
								{ x: c2.x, y: c2.y }
							]);
						}
					}
				}

				return voronoiEdges;
			}
		}

		// Quality metrics
		function triangleArea(a, b, c) {
			return Math.abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) / 2;
		}

		function triangleAngles(a, b, c) {
			const ab = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
			const bc = Math.sqrt((c.x - b.x) ** 2 + (c.y - b.y) ** 2);
			const ca = Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2);

			const angleA = Math.acos(Math.max(-1, Math.min(1, (ab * ab + ca * ca - bc * bc) / (2 * ab * ca))));
			const angleB = Math.acos(Math.max(-1, Math.min(1, (ab * ab + bc * bc - ca * ca) / (2 * ab * bc))));
			const angleC = Math.PI - angleA - angleB;

			return [angleA, angleB, angleC].map(a => a * 180 / Math.PI);
		}

		function triangleAspectRatio(a, b, c) {
			const area = triangleArea(a, b, c);
			if (area < 1e-10) return Infinity;

			const ab = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
			const bc = Math.sqrt((c.x - b.x) ** 2 + (c.y - b.y) ** 2);
			const ca = Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2);
			const s = (ab + bc + ca) / 2;

			// Inradius
			const inradius = area / s;
			// Circumradius
			const circumradius = (ab * bc * ca) / (4 * area);

			return circumradius / (2 * inradius);
		}

		// Get color based on value and mode
		function getTriangleColor(tri, index, total, allTriangles) {
			switch (colorMode) {
				case 'area': {
					const areas = allTriangles.map(t => triangleArea(...t.vertices));
					const maxArea = Math.max(...areas);
					const minArea = Math.min(...areas);
					const area = triangleArea(...tri.vertices);
					const t = maxArea > minArea ? (area - minArea) / (maxArea - minArea) : 0.5;
					return lerpColor('#48dbfb', '#ff6b6b', t);
				}
				case 'angle': {
					const angles = triangleAngles(...tri.vertices);
					const minAngle = Math.min(...angles);
					// 60 degrees is ideal (equilateral), 0 is worst
					const t = Math.min(minAngle / 60, 1);
					return lerpColor('#ff6b6b', '#1dd1a1', t);
				}
				case 'aspect': {
					const aspect = triangleAspectRatio(...tri.vertices);
					// 1 is ideal (equilateral), higher is worse
					const t = Math.max(0, 1 - (aspect - 1) / 3);
					return lerpColor('#ff6b6b', '#1dd1a1', t);
				}
				default: {
					// Gradient based on centroid position
					const cx = (tri.vertices[0].x + tri.vertices[1].x + tri.vertices[2].x) / 3;
					const cy = (tri.vertices[0].y + tri.vertices[1].y + tri.vertices[2].y) / 3;
					const t = (cx / canvas.offsetWidth + cy / canvas.offsetHeight) / 2;
					const colorIndex = Math.floor(t * (gradientColors.length - 1));
					const localT = (t * (gradientColors.length - 1)) % 1;
					return lerpColor(
						gradientColors[colorIndex],
						gradientColors[Math.min(colorIndex + 1, gradientColors.length - 1)],
						localT
					);
				}
			}
		}

		function lerpColor(c1, c2, t) {
			const r1 = parseInt(c1.slice(1, 3), 16);
			const g1 = parseInt(c1.slice(3, 5), 16);
			const b1 = parseInt(c1.slice(5, 7), 16);
			const r2 = parseInt(c2.slice(1, 3), 16);
			const g2 = parseInt(c2.slice(3, 5), 16);
			const b2 = parseInt(c2.slice(5, 7), 16);

			const r = Math.round(r1 + (r2 - r1) * t);
			const g = Math.round(g1 + (g2 - g1) * t);
			const b = Math.round(b1 + (b2 - b1) * t);

			return `rgb(${r},${g},${b})`;
		}

		function hexToRgba(hex, alpha) {
			const r = parseInt(hex.slice(1, 3), 16);
			const g = parseInt(hex.slice(3, 5), 16);
			const b = parseInt(hex.slice(5, 7), 16);
			return `rgba(${r},${g},${b},${alpha})`;
		}

		// Render the visualization
		function render() {
			const w = canvas.offsetWidth;
			const h = canvas.offsetHeight;

			// Clear with gradient background
			const gradient = ctx.createLinearGradient(0, 0, w, h);
			gradient.addColorStop(0, '#1a1a2e');
			gradient.addColorStop(0.5, '#16213e');
			gradient.addColorStop(1, '#0f3460');
			ctx.fillStyle = gradient;
			ctx.fillRect(0, 0, w, h);

			if (points.length < 3) {
				updateStats(points.length, 0, 0, '--', '--');

				// Draw existing points even if < 3
				if (showPoints && points.length > 0) {
					for (const point of points) {
						drawPoint(point, point === hoveredPoint);
					}
				}
				return;
			}

			// Compute triangulation
			triangulation = new DelaunayTriangulation(points, w, h);

			// Draw filled triangles
			if (showTriangles) {
				for (let i = 0; i < triangulation.triangles.length; i++) {
					const tri = triangulation.triangles[i];
					const color = getTriangleColor(tri, i, triangulation.triangles.length, triangulation.triangles);

					ctx.beginPath();
					ctx.moveTo(tri.vertices[0].x, tri.vertices[0].y);
					ctx.lineTo(tri.vertices[1].x, tri.vertices[1].y);
					ctx.lineTo(tri.vertices[2].x, tri.vertices[2].y);
					ctx.closePath();

					ctx.fillStyle = hexToRgba(color, 0.4);
					ctx.fill();
				}
			}

			// Draw circumcircles
			if (showCircumcircles) {
				ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
				ctx.lineWidth = 1;

				for (const tri of triangulation.triangles) {
					const c = tri.circumcircle;
					if (c.r < Infinity && c.r < w) {
						ctx.beginPath();
						ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
						ctx.stroke();

						// Draw circumcenter
						ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
						ctx.beginPath();
						ctx.arc(c.x, c.y, 3, 0, Math.PI * 2);
						ctx.fill();
					}
				}
			}

			// Draw Voronoi dual
			if (showVoronoi) {
				const voronoiEdges = triangulation.getVoronoiEdges();
				ctx.strokeStyle = 'rgba(254, 202, 87, 0.6)';
				ctx.lineWidth = 1.5;
				ctx.setLineDash([5, 5]);

				for (const [p1, p2] of voronoiEdges) {
					ctx.beginPath();
					ctx.moveTo(p1.x, p1.y);
					ctx.lineTo(p2.x, p2.y);
					ctx.stroke();
				}

				ctx.setLineDash([]);
			}

			// Draw edges
			if (showEdges) {
				ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
				ctx.lineWidth = 1.5;

				for (const tri of triangulation.triangles) {
					ctx.beginPath();
					ctx.moveTo(tri.vertices[0].x, tri.vertices[0].y);
					ctx.lineTo(tri.vertices[1].x, tri.vertices[1].y);
					ctx.lineTo(tri.vertices[2].x, tri.vertices[2].y);
					ctx.closePath();
					ctx.stroke();
				}
			}

			// Draw points
			if (showPoints) {
				for (const point of points) {
					drawPoint(point, point === hoveredPoint);
				}
			}

			// Calculate and update stats
			const numEdges = triangulation.getEdges();
			let minAngle = Infinity;
			let totalAspect = 0;

			for (const tri of triangulation.triangles) {
				const angles = triangleAngles(...tri.vertices);
				minAngle = Math.min(minAngle, ...angles);
				totalAspect += triangleAspectRatio(...tri.vertices);
			}

			const avgAspect = triangulation.triangles.length > 0
				? totalAspect / triangulation.triangles.length
				: 0;

			updateStats(
				points.length,
				triangulation.triangles.length,
				numEdges,
				minAngle === Infinity ? '--' : minAngle.toFixed(1) + '°',
				avgAspect === 0 ? '--' : avgAspect.toFixed(2)
			);
		}

		function drawPoint(point, isHovered) {
			const radius = isHovered ? 8 : 6;

			// Glow effect
			ctx.shadowColor = '#48dbfb';
			ctx.shadowBlur = isHovered ? 15 : 8;

			ctx.fillStyle = isHovered ? '#ffffff' : '#48dbfb';
			ctx.beginPath();
			ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
			ctx.fill();

			ctx.shadowBlur = 0;

			// Border
			ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
			ctx.lineWidth = 2;
			ctx.stroke();
		}

		function updateStats(numPoints, numTriangles, numEdges, minAngle, avgAspect) {
			document.getElementById('statPoints').textContent = numPoints;
			document.getElementById('statTriangles').textContent = numTriangles;
			document.getElementById('statEdges').textContent = numEdges;

			const minAngleEl = document.getElementById('statMinAngle');
			minAngleEl.textContent = minAngle;
			minAngleEl.className = 'value';
			if (typeof minAngle === 'string' && minAngle !== '--') {
				const angle = parseFloat(minAngle);
				if (angle >= 30) minAngleEl.classList.add('good');
				else if (angle >= 15) minAngleEl.classList.add('warn');
				else minAngleEl.classList.add('bad');
			}

			const aspectEl = document.getElementById('statAspect');
			aspectEl.textContent = avgAspect;
			aspectEl.className = 'value';
			if (typeof avgAspect === 'string' && avgAspect !== '--') {
				const aspect = parseFloat(avgAspect);
				if (aspect <= 1.5) aspectEl.classList.add('good');
				else if (aspect <= 2.5) aspectEl.classList.add('warn');
				else aspectEl.classList.add('bad');
			}
		}

		// Mouse handling
		function getMousePos(e) {
			const rect = canvas.getBoundingClientRect();
			return {
				x: e.clientX - rect.left,
				y: e.clientY - rect.top
			};
		}

		function findNearestPoint(pos, maxDist = 15) {
			let nearest = null;
			let minDist = maxDist;

			for (const point of points) {
				const dx = pos.x - point.x;
				const dy = pos.y - point.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < minDist) {
					minDist = dist;
					nearest = point;
				}
			}

			return nearest;
		}

		canvas.addEventListener('mousedown', (e) => {
			if (isAnimating) return;

			const pos = getMousePos(e);

			if (e.button === 2) {
				// Right-click: delete point
				e.preventDefault();
				const point = findNearestPoint(pos);
				if (point) {
					points = points.filter(p => p !== point);
					hoveredPoint = null;
					render();
				}
				return;
			}

			// Left-click: add or drag
			draggedPoint = findNearestPoint(pos);
			if (!draggedPoint) {
				points.push({ x: pos.x, y: pos.y });
				render();
			}
		});

		canvas.addEventListener('mousemove', (e) => {
			const pos = getMousePos(e);

			if (draggedPoint) {
				draggedPoint.x = pos.x;
				draggedPoint.y = pos.y;
				render();
			} else {
				const newHovered = findNearestPoint(pos);
				if (newHovered !== hoveredPoint) {
					hoveredPoint = newHovered;
					render();
				}
			}
		});

		canvas.addEventListener('mouseup', () => {
			draggedPoint = null;
		});

		canvas.addEventListener('mouseleave', () => {
			draggedPoint = null;
			if (hoveredPoint) {
				hoveredPoint = null;
				render();
			}
		});

		canvas.addEventListener('contextmenu', (e) => e.preventDefault());

		// Controls
		document.getElementById('btnClear').addEventListener('click', () => {
			if (isAnimating) stopAnimation();
			points = [];
			hoveredPoint = null;
			render();
		});

		document.getElementById('btnRandom').addEventListener('click', () => {
			if (isAnimating) stopAnimation();

			const n = parseInt(document.getElementById('numRandom').value);
			const w = canvas.offsetWidth;
			const h = canvas.offsetHeight;
			const margin = 40;

			points = [];
			for (let i = 0; i < n; i++) {
				points.push({
					x: margin + Math.random() * (w - margin * 2),
					y: margin + Math.random() * (h - margin * 2)
				});
			}
			render();
		});

		document.getElementById('chkTriangles').addEventListener('change', (e) => {
			showTriangles = e.target.checked;
			render();
		});

		document.getElementById('chkEdges').addEventListener('change', (e) => {
			showEdges = e.target.checked;
			render();
		});

		document.getElementById('chkPoints').addEventListener('change', (e) => {
			showPoints = e.target.checked;
			render();
		});

		document.getElementById('chkCircumcircles').addEventListener('change', (e) => {
			showCircumcircles = e.target.checked;
			render();
		});

		document.getElementById('chkVoronoi').addEventListener('change', (e) => {
			showVoronoi = e.target.checked;
			render();
		});

		document.getElementById('colorMode').addEventListener('change', (e) => {
			colorMode = e.target.value;
			render();
		});

		// Animation
		document.getElementById('btnAnimate').addEventListener('click', startAnimation);
		document.getElementById('btnStopAnim').addEventListener('click', stopAnimation);
		document.getElementById('animSpeed').addEventListener('input', (e) => {
			animationSpeed = parseInt(e.target.value);
		});

		function startAnimation() {
			if (points.length < 3) return;

			isAnimating = true;
			animationPoints = [...points];
			points = [];
			animationIndex = 0;

			document.getElementById('btnAnimate').classList.add('active');
			document.getElementById('animControls').classList.add('visible');

			animateStep();
		}

		function stopAnimation() {
			isAnimating = false;
			points = [...animationPoints];
			animationPoints = [];

			document.getElementById('btnAnimate').classList.remove('active');
			document.getElementById('animControls').classList.remove('visible');

			render();
		}

		function animateStep() {
			if (!isAnimating) return;

			if (animationIndex < animationPoints.length) {
				points.push(animationPoints[animationIndex]);
				animationIndex++;
				render();

				const delay = Math.max(50, 500 - animationSpeed * 45);
				setTimeout(animateStep, delay);
			} else {
				// Animation complete
				isAnimating = false;
				document.getElementById('btnAnimate').classList.remove('active');
				document.getElementById('animControls').classList.remove('visible');
			}
		}

		// Initialize
		resizeCanvas();
		document.getElementById('btnRandom').click();
	</script>
</body>
</html>
