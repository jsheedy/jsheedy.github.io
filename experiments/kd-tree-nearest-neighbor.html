<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-d Tree Nearest Neighbor</title>
    <style>
        :root {
            color-scheme: light;
            --bg-deep: #0f1f2b;
            --bg-mid: #2c3a4a;
            --panel: #f6f2e9;
            --panel-strong: #ffffff;
            --ink: #1a2b34;
            --accent: #f05d5e;
            --accent-2: #3a86ff;
            --accent-3: #ffbe0b;
            --muted: #6b7a86;
            --grid: rgba(15, 31, 43, 0.08);
            --shadow: 0 20px 45px rgba(10, 20, 30, 0.25);
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "Futura", "Trebuchet MS", "Avenir Next", sans-serif;
            color: var(--ink);
            background:
                radial-gradient(circle at 15% 20%, rgba(255, 190, 11, 0.35), transparent 50%),
                radial-gradient(circle at 80% 10%, rgba(58, 134, 255, 0.25), transparent 55%),
                linear-gradient(160deg, var(--bg-deep), var(--bg-mid));
            display: flex;
            justify-content: center;
            padding: 32px 18px 48px;
        }

        .frame {
            width: min(1200px, 100%);
            background: var(--panel);
            border-radius: 24px;
            box-shadow: var(--shadow);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        h1 {
            margin: 0;
            font-size: clamp(26px, 3vw, 34px);
            letter-spacing: 1px;
        }

        .subtitle {
            color: var(--muted);
            font-size: 15px;
            line-height: 1.5;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(0, 1.5fr) minmax(0, 0.9fr);
            gap: 24px;
            align-items: start;
        }

        .panel {
            background: var(--panel-strong);
            border-radius: 18px;
            padding: 18px;
            box-shadow: inset 0 0 0 1px rgba(15, 31, 43, 0.06);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 16px;
            border: 1px solid rgba(15, 31, 43, 0.1);
            background: repeating-linear-gradient(
                0deg,
                #fdfbf7 0,
                #fdfbf7 24px,
                var(--grid) 24px,
                var(--grid) 25px
            );
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 12px;
            font-size: 12px;
            color: var(--muted);
        }

        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .controls {
            display: grid;
            gap: 14px;
        }

        .control-card {
            background: var(--panel-strong);
            border-radius: 16px;
            padding: 14px;
            box-shadow: inset 0 0 0 1px rgba(15, 31, 43, 0.08);
        }

        .control-card h2 {
            margin: 0 0 10px;
            font-size: 15px;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: grid;
            gap: 8px;
            margin-bottom: 10px;
        }

        label {
            font-size: 13px;
            color: var(--muted);
        }

        input[type="range"] {
            width: 100%;
        }

        .toggle-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .toggle {
            flex: 1 1 auto;
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid rgba(15, 31, 43, 0.2);
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            color: var(--ink);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .toggle.active {
            background: var(--accent-2);
            color: white;
            border-color: transparent;
            box-shadow: 0 8px 18px rgba(58, 134, 255, 0.25);
        }

        .toggle:active {
            transform: scale(0.98);
        }

        .actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
        }

        .action {
            padding: 10px;
            border-radius: 10px;
            border: none;
            background: var(--accent);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .action.secondary {
            background: var(--accent-3);
            color: #2e2a1e;
        }

        .action:active {
            transform: translateY(1px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .stat {
            background: rgba(15, 31, 43, 0.05);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
        }

        .stat strong {
            display: block;
            font-size: 20px;
        }

        .tree-panel {
            display: none;
            margin-top: 14px;
        }

        .tree-panel.active {
            display: block;
        }

        .tree-panel canvas {
            background: #ffffff;
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="frame">
        <header>
            <h1>K-d Tree Nearest Neighbor</h1>
            <div class="subtitle">
                Build a k-d tree, switch between add and query modes, and compare the search path against brute force. Splitting planes alternate by axis, while search visits animate through the tree.
            </div>
        </header>

        <div class="layout">
            <div class="panel">
                <canvas id="field" width="900" height="600"></canvas>
                <div class="legend">
                    <span><i class="dot" style="background: var(--accent);"></i>query point</span>
                    <span><i class="dot" style="background: var(--accent-2);"></i>nearest neighbors</span>
                    <span><i class="dot" style="background: var(--accent-3);"></i>visited nodes</span>
                    <span><i class="dot" style="background: #ef476f;"></i>x-axis split</span>
                    <span><i class="dot" style="background: #3a86ff;"></i>y-axis split</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-card">
                    <h2>Interaction</h2>
                    <div class="toggle-row" id="modeToggles">
                        <button class="toggle active" data-mode="add">Add points</button>
                        <button class="toggle" data-mode="query">Query nearest</button>
                    </div>
                    <div class="actions" style="margin-top: 10px;">
                        <button class="action" id="randomize">Randomize</button>
                        <button class="action secondary" id="clear">Clear</button>
                    </div>
                </div>

                <div class="control-card">
                    <h2>Parameters</h2>
                    <div class="control-group">
                        <label>Point count: <span id="countLabel">120</span></label>
                        <input id="count" type="range" min="10" max="500" step="10" value="120">
                    </div>
                    <div class="control-group">
                        <label>K nearest: <span id="kLabel">1</span></label>
                        <input id="k" type="range" min="1" max="8" step="1" value="1">
                    </div>
                    <div class="control-group">
                        <label>Animation speed: <span id="speedLabel">140</span> ms/node</label>
                        <input id="speed" type="range" min="40" max="400" step="10" value="140">
                    </div>
                </div>

                <div class="control-card">
                    <h2>Visualization</h2>
                    <div class="toggle-row">
                        <button class="toggle active" id="splitToggle">Splitting planes</button>
                        <button class="toggle" id="treeToggle">Tree view</button>
                    </div>
                </div>

                <div class="control-card">
                    <h2>Stats</h2>
                    <div class="stats">
                        <div class="stat"><strong id="statPoints">0</strong>points</div>
                        <div class="stat"><strong id="statDepth">0</strong>depth</div>
                        <div class="stat"><strong id="statBalance">0</strong>balance</div>
                        <div class="stat"><strong id="statVisited">0</strong>kd visits</div>
                        <div class="stat"><strong id="statBrute">0</strong>brute checks</div>
                    </div>
                </div>

                <div class="control-card tree-panel" id="treePanel">
                    <h2>Tree Structure</h2>
                    <canvas id="tree" width="360" height="420"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const field = document.getElementById('field');
        const ctx = field.getContext('2d');
        const treeCanvas = document.getElementById('tree');
        const treeCtx = treeCanvas.getContext('2d');

        const countInput = document.getElementById('count');
        const kInput = document.getElementById('k');
        const speedInput = document.getElementById('speed');
        const countLabel = document.getElementById('countLabel');
        const kLabel = document.getElementById('kLabel');
        const speedLabel = document.getElementById('speedLabel');
        const splitToggle = document.getElementById('splitToggle');
        const treeToggle = document.getElementById('treeToggle');
        const treePanel = document.getElementById('treePanel');
        const modeToggles = document.getElementById('modeToggles');

        const statPoints = document.getElementById('statPoints');
        const statDepth = document.getElementById('statDepth');
        const statBalance = document.getElementById('statBalance');
        const statVisited = document.getElementById('statVisited');
        const statBrute = document.getElementById('statBrute');

        const randomizeButton = document.getElementById('randomize');
        const clearButton = document.getElementById('clear');

        let points = [];
        let root = null;
        let queryPoint = null;
        let neighborResult = [];
        let visitedOrder = [];
        let animationStart = 0;
        let mode = 'add';
        let showSplits = true;
        let showTree = false;
        let nodeId = 0;

        function randomPoint() {
            const padding = 30;
            return {
                x: padding + Math.random() * (field.width - padding * 2),
                y: padding + Math.random() * (field.height - padding * 2)
            };
        }

        function rebuildTree() {
            nodeId = 0;
            root = buildKdTree(points, 0, {
                minX: 0,
                maxX: field.width,
                minY: 0,
                maxY: field.height
            });
            updateStats();
            runQuery();
        }

        function buildKdTree(list, depth, bounds) {
            if (!list.length) return null;
            const axis = depth % 2;
            const sorted = [...list].sort((a, b) => (axis === 0 ? a.x - b.x : a.y - b.y));
            const median = Math.floor(sorted.length / 2);
            const point = sorted[median];
            const leftPoints = sorted.slice(0, median);
            const rightPoints = sorted.slice(median + 1);
            const nodeBounds = { ...bounds };

            const leftBounds = { ...bounds };
            const rightBounds = { ...bounds };
            if (axis === 0) {
                leftBounds.maxX = point.x;
                rightBounds.minX = point.x;
            } else {
                leftBounds.maxY = point.y;
                rightBounds.minY = point.y;
            }

            return {
                id: nodeId++,
                point,
                axis,
                depth,
                bounds: nodeBounds,
                left: buildKdTree(leftPoints, depth + 1, leftBounds),
                right: buildKdTree(rightPoints, depth + 1, rightBounds)
            };
        }

        function rectDistanceSq(target, bounds) {
            let dx = 0;
            if (target.x < bounds.minX) dx = bounds.minX - target.x;
            else if (target.x > bounds.maxX) dx = target.x - bounds.maxX;
            let dy = 0;
            if (target.y < bounds.minY) dy = bounds.minY - target.y;
            else if (target.y > bounds.maxY) dy = target.y - bounds.maxY;
            return dx * dx + dy * dy;
        }

        function insertNeighbor(list, candidate, k) {
            list.push(candidate);
            list.sort((a, b) => a.dist - b.dist);
            if (list.length > k) list.pop();
        }

        function kdSearch(node, target, k, result, visited) {
            if (!node) return;
            visited.push(node);
            const dx = node.point.x - target.x;
            const dy = node.point.y - target.y;
            const dist = dx * dx + dy * dy;
            insertNeighbor(result, { node, dist }, k);

            const axis = node.axis;
            const diff = axis === 0 ? target.x - node.point.x : target.y - node.point.y;
            const near = diff < 0 ? node.left : node.right;
            const far = diff < 0 ? node.right : node.left;

            kdSearch(near, target, k, result, visited);
            const worst = result.length < k ? Infinity : result[result.length - 1].dist;
            if (far && rectDistanceSq(target, far.bounds) <= worst) {
                kdSearch(far, target, k, result, visited);
            }
        }

        function bruteForce(target, k) {
            const results = points.map((point) => {
                const dx = point.x - target.x;
                const dy = point.y - target.y;
                return { point, dist: dx * dx + dy * dy };
            });
            results.sort((a, b) => a.dist - b.dist);
            return results.slice(0, k);
        }

        function runQuery() {
            if (!queryPoint || !root) {
                neighborResult = [];
                visitedOrder = [];
                updateStats();
                return;
            }
            const result = [];
            const visited = [];
            kdSearch(root, queryPoint, Number(kInput.value), result, visited);
            neighborResult = result;
            visitedOrder = visited;
            animationStart = performance.now();
            const brute = bruteForce(queryPoint, Number(kInput.value));
            statVisited.textContent = visitedOrder.length;
            statBrute.textContent = brute.length ? points.length : 0;
        }

        function updateStats() {
            const { maxDepth, minDepth } = computeDepthStats(root);
            statPoints.textContent = points.length;
            statDepth.textContent = maxDepth;
            const balance = minDepth === 0 ? 0 : (maxDepth / minDepth).toFixed(2);
            statBalance.textContent = balance;
            if (!queryPoint) {
                statVisited.textContent = 0;
                statBrute.textContent = 0;
            }
        }

        function computeDepthStats(node) {
            if (!node) return { maxDepth: 0, minDepth: 0 };
            if (!node.left && !node.right) return { maxDepth: node.depth, minDepth: node.depth };
            const left = computeDepthStats(node.left);
            const right = computeDepthStats(node.right);
            const maxDepth = Math.max(left.maxDepth, right.maxDepth, node.depth);
            const minDepth = Math.min(
                left.minDepth || node.depth,
                right.minDepth || node.depth,
                node.depth
            );
            return { maxDepth, minDepth };
        }

        function drawSplits(node) {
            if (!node) return;
            const { point, bounds, axis } = node;
            ctx.strokeStyle = axis === 0 ? '#ef476f' : '#3a86ff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            if (axis === 0) {
                ctx.moveTo(point.x, bounds.minY);
                ctx.lineTo(point.x, bounds.maxY);
            } else {
                ctx.moveTo(bounds.minX, point.y);
                ctx.lineTo(bounds.maxX, point.y);
            }
            ctx.stroke();
            drawSplits(node.left);
            drawSplits(node.right);
        }

        function drawPoints() {
            ctx.fillStyle = '#1f2d3a';
            points.forEach((point) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawQuery() {
            if (!queryPoint) return;
            ctx.fillStyle = '#f05d5e';
            ctx.beginPath();
            ctx.arc(queryPoint.x, queryPoint.y, 6, 0, Math.PI * 2);
            ctx.fill();

            const radius = neighborResult.length
                ? Math.sqrt(neighborResult[neighborResult.length - 1].dist)
                : 0;
            if (radius) {
                ctx.strokeStyle = 'rgba(240, 93, 94, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(queryPoint.x, queryPoint.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawNeighbors() {
            if (!queryPoint) return;
            ctx.strokeStyle = 'rgba(58, 134, 255, 0.45)';
            ctx.lineWidth = 2;
            neighborResult.forEach((entry) => {
                const point = entry.node.point;
                ctx.beginPath();
                ctx.moveTo(queryPoint.x, queryPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
                ctx.fillStyle = '#3a86ff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawVisited() {
            if (!visitedOrder.length) return;
            const interval = Number(speedInput.value);
            const revealed = Math.min(
                visitedOrder.length,
                Math.floor((performance.now() - animationStart) / interval) + 1
            );
            ctx.fillStyle = '#ffbe0b';
            for (let i = 0; i < revealed; i++) {
                const node = visitedOrder[i];
                ctx.beginPath();
                ctx.arc(node.point.x, node.point.y, 7, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawField() {
            ctx.clearRect(0, 0, field.width, field.height);
            if (showSplits) drawSplits(root);
            drawPoints();
            drawVisited();
            drawNeighbors();
            drawQuery();
        }

        function layoutTree(node, minX, maxX, levelHeight, positions) {
            if (!node) return;
            const x = (minX + maxX) / 2;
            const y = 30 + node.depth * levelHeight;
            positions.set(node.id, { x, y, node });
            if (node.left) layoutTree(node.left, minX, x, levelHeight, positions);
            if (node.right) layoutTree(node.right, x, maxX, levelHeight, positions);
        }

        function drawTree() {
            if (!showTree) return;
            treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
            if (!root) return;
            const positions = new Map();
            const levelHeight = 50;
            layoutTree(root, 20, treeCanvas.width - 20, levelHeight, positions);
            const interval = Number(speedInput.value);
            const revealed = Math.min(
                visitedOrder.length,
                Math.floor((performance.now() - animationStart) / interval) + 1
            );
            const visitedSet = new Set(visitedOrder.slice(0, revealed).map((node) => node.id));

            positions.forEach(({ node, x, y }) => {
                if (node.left) {
                    const child = positions.get(node.left.id);
                    treeCtx.strokeStyle = 'rgba(26, 43, 52, 0.2)';
                    treeCtx.beginPath();
                    treeCtx.moveTo(x, y);
                    treeCtx.lineTo(child.x, child.y);
                    treeCtx.stroke();
                }
                if (node.right) {
                    const child = positions.get(node.right.id);
                    treeCtx.strokeStyle = 'rgba(26, 43, 52, 0.2)';
                    treeCtx.beginPath();
                    treeCtx.moveTo(x, y);
                    treeCtx.lineTo(child.x, child.y);
                    treeCtx.stroke();
                }
            });

            positions.forEach(({ node, x, y }) => {
                const isVisited = visitedSet.has(node.id);
                treeCtx.fillStyle = isVisited ? '#ffbe0b' : (node.axis === 0 ? '#ef476f' : '#3a86ff');
                treeCtx.beginPath();
                treeCtx.arc(x, y, 8, 0, Math.PI * 2);
                treeCtx.fill();
            });
        }

        function animate() {
            drawField();
            drawTree();
            requestAnimationFrame(animate);
        }

        function setMode(newMode) {
            mode = newMode;
            [...modeToggles.children].forEach((btn) => {
                btn.classList.toggle('active', btn.dataset.mode === newMode);
            });
        }

        field.addEventListener('click', (event) => {
            const rect = field.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (field.width / rect.width);
            const y = (event.clientY - rect.top) * (field.height / rect.height);
            if (mode === 'add') {
                points.push({ x, y });
                rebuildTree();
            } else {
                queryPoint = { x, y };
                runQuery();
            }
        });

        modeToggles.addEventListener('click', (event) => {
            const target = event.target.closest('button');
            if (!target) return;
            setMode(target.dataset.mode);
        });

        splitToggle.addEventListener('click', () => {
            showSplits = !showSplits;
            splitToggle.classList.toggle('active', showSplits);
        });

        treeToggle.addEventListener('click', () => {
            showTree = !showTree;
            treeToggle.classList.toggle('active', showTree);
            treePanel.classList.toggle('active', showTree);
        });

        randomizeButton.addEventListener('click', () => {
            points = Array.from({ length: Number(countInput.value) }, randomPoint);
            queryPoint = null;
            rebuildTree();
        });

        clearButton.addEventListener('click', () => {
            points = [];
            queryPoint = null;
            rebuildTree();
        });

        countInput.addEventListener('input', () => {
            countLabel.textContent = countInput.value;
        });

        countInput.addEventListener('change', () => {
            points = Array.from({ length: Number(countInput.value) }, randomPoint);
            queryPoint = null;
            rebuildTree();
        });

        kInput.addEventListener('input', () => {
            kLabel.textContent = kInput.value;
            runQuery();
        });

        speedInput.addEventListener('input', () => {
            speedLabel.textContent = speedInput.value;
        });

        function init() {
            countLabel.textContent = countInput.value;
            kLabel.textContent = kInput.value;
            speedLabel.textContent = speedInput.value;
            points = Array.from({ length: Number(countInput.value) }, randomPoint);
            rebuildTree();
            animate();
        }

        init();
    </script>
</body>
</html>
