<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verlet Soft Body Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e0a;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, #0d120d 0%, #0a0e0a 100%);
            border-bottom: 1px solid #00ff41;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .back-link {
            color: #00ff41;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .back-link:hover {
            opacity: 1;
            text-shadow: 0 0 10px #00ff41;
        }

        .title {
            font-size: 1.4em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
            letter-spacing: 2px;
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 0.85em;
            opacity: 0.8;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebars */
        .sidebar {
            width: 280px;
            background: #0d120d;
            border-right: 1px solid rgba(0, 255, 65, 0.3);
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar-right {
            border-right: none;
            border-left: 1px solid rgba(0, 255, 65, 0.3);
        }

        .sidebar h2 {
            font-size: 1em;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section h3 {
            font-size: 0.9em;
            color: #00cc33;
            margin-bottom: 8px;
        }

        .sidebar p, .sidebar li {
            font-size: 0.8em;
            line-height: 1.6;
            color: #00aa2a;
        }

        .sidebar ul {
            list-style: none;
            padding-left: 10px;
        }

        .sidebar li::before {
            content: '>';
            margin-right: 8px;
            color: #00ff41;
        }

        .equation {
            background: rgba(0, 255, 65, 0.05);
            padding: 8px 12px;
            margin: 10px 0;
            border-left: 2px solid #00ff41;
            font-size: 0.85em;
            white-space: pre;
        }

        .info-box {
            background: rgba(0, 255, 65, 0.08);
            border: 1px solid rgba(0, 255, 65, 0.2);
            padding: 12px;
            margin-bottom: 15px;
        }

        .info-box h4 {
            font-size: 0.9em;
            margin-bottom: 8px;
            color: #00ff41;
        }

        .info-box p {
            font-size: 0.75em;
            line-height: 1.5;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #080a08;
            position: relative;
        }

        #mainCanvas {
            flex: 1;
            width: 100%;
            cursor: crosshair;
        }

        /* Controls */
        .controls {
            background: #0d120d;
            border-top: 1px solid rgba(0, 255, 65, 0.3);
            padding: 15px 20px;
        }

        .controls-row {
            display: flex;
            gap: 30px;
            align-items: center;
            margin-bottom: 12px;
        }

        .controls-row:last-child {
            margin-bottom: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 0.85em;
            white-space: nowrap;
        }

        select {
            background: #0a0e0a;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 6px 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            cursor: pointer;
            min-width: 140px;
        }

        select:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: #0a0e0a;
            height: 6px;
            border: 1px solid #00ff41;
            width: 120px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #00ff41;
            cursor: pointer;
            border-radius: 0;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #00ff41;
            cursor: pointer;
            border-radius: 0;
            border: none;
        }

        .btn {
            background: transparent;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
        }

        .btn.active {
            background: #00ff41;
            color: #0a0e0a;
        }

        .value-display {
            font-size: 0.8em;
            min-width: 60px;
            text-align: right;
            color: #00aa2a;
        }

        .tool-buttons {
            display: flex;
            gap: 8px;
        }

        .tool-btn {
            padding: 6px 12px;
            font-size: 0.8em;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .checkbox-item input {
            cursor: pointer;
            accent-color: #00ff41;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0e0a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff41;
            border: 1px solid #0a0e0a;
        }

        /* Canvas overlay for stats */
        .canvas-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 14, 10, 0.85);
            border: 1px solid rgba(0, 255, 65, 0.3);
            padding: 10px;
            font-size: 0.75em;
            pointer-events: none;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 4px;
        }

        .stat-label {
            color: #00aa2a;
        }

        .stat-value {
            color: #00ff41;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Hide sidebars on mobile */
            .sidebar {
                display: none;
            }

            /* Compact header */
            .header {
                padding: 8px 12px;
                flex-wrap: wrap;
            }

            .header-left {
                gap: 10px;
            }

            .title {
                font-size: 1em;
                letter-spacing: 1px;
            }

            .header-stats {
                gap: 10px;
                font-size: 0.7em;
            }

            .header-stats span {
                display: none;
            }

            .header-stats span:first-child,
            .header-stats span:last-child {
                display: inline;
            }

            /* Compact controls */
            .controls {
                padding: 10px;
            }

            .controls-row {
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 8px;
            }

            .control-group {
                gap: 6px;
                font-size: 0.8em;
            }

            .control-group label {
                font-size: 0.75em;
            }

            input[type="range"] {
                width: 80px;
            }

            select {
                min-width: 100px;
                padding: 4px 8px;
                font-size: 0.75em;
            }

            .btn {
                padding: 6px 10px;
                font-size: 0.75em;
            }

            .tool-btn {
                padding: 5px 8px;
                font-size: 0.7em;
            }

            .tool-buttons {
                gap: 4px;
            }

            .value-display {
                min-width: 40px;
                font-size: 0.7em;
            }

            /* Smaller canvas overlay */
            .canvas-overlay {
                top: 5px;
                right: 5px;
                padding: 6px;
                font-size: 0.65em;
            }

            .stat-row {
                gap: 10px;
                margin-bottom: 2px;
            }

            /* Hide some stats on very small screens */
            @media (max-width: 480px) {
                .canvas-overlay .stat-row:nth-child(3),
                .canvas-overlay .stat-row:nth-child(4) {
                    display: none;
                }
            }
        }

        /* Very small screens - iPhone SE, etc */
        @media (max-width: 400px) {
            .title {
                font-size: 0.85em;
            }

            .back-link {
                font-size: 0.85em;
            }

            .header-stats {
                font-size: 0.65em;
            }

            .controls {
                padding: 8px;
            }

            .control-group label {
                font-size: 0.7em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <a href="index.html" class="back-link">&#9664; experiments</a>
            <span class="title">VERLET SOFT BODY PHYSICS</span>
        </div>
        <div class="header-stats">
            <span>Points: <span id="pointCount">0</span></span>
            <span>Constraints: <span id="constraintCount">0</span></span>
            <span>FPS: <span id="fps">0</span></span>
        </div>
    </div>

    <div class="main-container">
        <!-- Left Sidebar - About -->
        <div class="sidebar">
            <h2>About Verlet Physics</h2>

            <div class="sidebar-section">
                <h3>What is Verlet Integration?</h3>
                <p>Position-based dynamics that stores position history instead of explicit velocity:</p>
                <div class="equation">x_new = x + (x - x_old) + a*dt²</div>
                <p>Highly stable for constrained systems like cloth, ropes, and soft bodies.</p>
            </div>

            <div class="sidebar-section">
                <h3>Constraint Solving</h3>
                <ul>
                    <li><strong>Distance</strong> - Keep points at fixed distance</li>
                    <li><strong>Pin</strong> - Fix points in space</li>
                    <li><strong>Angle</strong> - Preserve bend resistance</li>
                </ul>
                <p style="margin-top: 8px;">Multiple iterations per frame increase rigidity.</p>
            </div>

            <div class="sidebar-section">
                <h3>Optimization</h3>
                <p><strong>Spatial Hashing:</strong> O(n) collision detection instead of O(n²). Each point only checks nearby neighbors.</p>
                <p style="margin-top: 8px;"><strong>Typed Arrays:</strong> Float32Array for better memory performance with many points.</p>
            </div>

            <div class="sidebar-section">
                <h3>Use Cases</h3>
                <ul>
                    <li>Game physics (cloth, hair, ropes)</li>
                    <li>Animation and VFX</li>
                    <li>Engineering simulation</li>
                    <li>Interactive art</li>
                </ul>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <div class="canvas-overlay">
                <div class="stat-row">
                    <span class="stat-label">Iterations:</span>
                    <span class="stat-value" id="iterationsStat">5</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Collision Checks:</span>
                    <span class="stat-value" id="collisionsStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Hash Cells:</span>
                    <span class="stat-value" id="hashCellsStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Tool:</span>
                    <span class="stat-value" id="currentToolStat">Grab</span>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - Presets -->
        <div class="sidebar sidebar-right">
            <h2>Presets & Tools</h2>

            <div class="info-box">
                <h4>Available Presets</h4>
                <p><strong>Cloth:</strong> Pinned fabric sheet with natural draping.</p>
                <p><strong>Rope:</strong> Hanging chain with one fixed end.</p>
                <p><strong>Chain:</strong> Rigid segments with bend resistance.</p>
                <p><strong>Jello:</strong> Squishy cube with internal pressure.</p>
                <p><strong>Ragdoll:</strong> Articulated figure with limbs.</p>
                <p><strong>Bridge:</strong> Suspended structure between anchors.</p>
                <p><strong>Hair:</strong> Multiple strands from fixed points.</p>
            </div>

            <div class="info-box">
                <h4>Interactive Tools</h4>
                <p><strong>Grab:</strong> Click and drag points around.</p>
                <p><strong>Pin:</strong> Click to fix/unfix points in space.</p>
                <p><strong>Cut:</strong> Click near constraints to tear them.</p>
                <p><strong>Add Circle:</strong> Drag to create circular obstacles.</p>
            </div>

            <div class="sidebar-section">
                <h3>Tips</h3>
                <p id="tipText">Try grabbing the cloth and shaking it. Watch how constraints maintain the fabric structure while allowing natural motion.</p>
            </div>

            <div class="sidebar-section">
                <h3>Performance</h3>
                <p>Spatial hashing reduces collision detection from O(n²) to O(n). Watch the collision check count stay low even with many points!</p>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="controls-row">
            <div class="control-group">
                <label>Preset:</label>
                <select id="presetSelect">
                    <option value="cloth">Cloth</option>
                    <option value="rope">Rope</option>
                    <option value="chain">Chain</option>
                    <option value="jello">Jello</option>
                    <option value="ragdoll">Ragdoll</option>
                    <option value="bridge">Bridge</option>
                    <option value="hair">Hair</option>
                </select>
            </div>

            <div class="control-group">
                <label>Tool:</label>
                <div class="tool-buttons">
                    <button class="btn tool-btn active" data-tool="grab">Grab</button>
                    <button class="btn tool-btn" data-tool="pin">Pin</button>
                    <button class="btn tool-btn" data-tool="cut">Cut</button>
                    <button class="btn tool-btn" data-tool="circle">Circle</button>
                </div>
            </div>

            <div class="control-group" style="margin-left: auto;">
                <button class="btn" id="clearBtn">Clear</button>
                <button class="btn" id="shakeBtn">Shake</button>
                <button class="btn" id="pauseBtn">Pause</button>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label>Gravity:</label>
                <input type="range" id="gravity" min="0" max="20" step="0.5" value="9.8">
                <span class="value-display" id="gravityValue">9.8</span>
            </div>

            <div class="control-group">
                <label>Iterations:</label>
                <input type="range" id="iterations" min="1" max="20" step="1" value="5">
                <span class="value-display" id="iterationsValue">5</span>
            </div>

            <div class="control-group">
                <label>Damping:</label>
                <input type="range" id="damping" min="0.9" max="0.999" step="0.001" value="0.99">
                <span class="value-display" id="dampingValue">0.99</span>
            </div>

            <div class="control-group">
                <label>Stiffness:</label>
                <input type="range" id="stiffness" min="0.1" max="1" step="0.05" value="1">
                <span class="value-display" id="stiffnessValue">1.0</span>
            </div>
        </div>

        <div class="controls-row">
            <div class="control-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="showPoints" checked>
                    <span>Points</span>
                </label>
            </div>
            <div class="control-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="showConstraints" checked>
                    <span>Constraints</span>
                </label>
            </div>
            <div class="control-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="showStress" checked>
                    <span>Stress Color</span>
                </label>
            </div>
            <div class="control-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="showGrid">
                    <span>Grid</span>
                </label>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================

        function lerpColor(color1, color2, t) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function getStressColor(stress, showStress) {
            if (!showStress) return '#00ff41';

            const t = Math.min(stress * 10, 1);
            if (t < 0.5) {
                return lerpColor('#00ff41', '#ffff00', t * 2);
            } else {
                return lerpColor('#ffff00', '#ff4444', (t - 0.5) * 2);
            }
        }

        // ============================================================
        // SPATIAL HASH
        // ============================================================

        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            getKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            }

            insert(point) {
                const key = this.getKey(point.x, point.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(point);
            }

            query(x, y, radius) {
                const results = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const centerX = Math.floor(x / this.cellSize);
                const centerY = Math.floor(y / this.cellSize);

                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                        const key = `${centerX + dx},${centerY + dy}`;
                        if (this.grid.has(key)) {
                            results.push(...this.grid.get(key));
                        }
                    }
                }

                return results;
            }

            clear() {
                this.grid.clear();
            }

            getCellCount() {
                return this.grid.size;
            }
        }

        // ============================================================
        // VERLET POINT
        // ============================================================

        class VerletPoint {
            constructor(x, y, mass = 1.0) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.mass = mass;
                this.pinned = false;
                this.forceX = 0;
                this.forceY = 0;
                this.radius = 4;
            }

            update(dt, damping, gravity) {
                if (this.pinned) return;

                const ax = this.forceX / this.mass;
                const ay = this.forceY / this.mass + gravity;

                const vx = (this.x - this.oldX) * damping;
                const vy = (this.y - this.oldY) * damping;

                this.oldX = this.x;
                this.oldY = this.y;
                this.x += vx + ax * dt * dt;
                this.y += vy + ay * dt * dt;

                this.forceX = 0;
                this.forceY = 0;
            }

            constrain(width, height) {
                if (this.pinned) return;

                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.oldX = this.x + (this.x - this.oldX) * 0.5;
                } else if (this.x > width - this.radius) {
                    this.x = width - this.radius;
                    this.oldX = this.x + (this.x - this.oldX) * 0.5;
                }

                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.oldY = this.y + (this.y - this.oldY) * 0.5;
                } else if (this.y > height - this.radius) {
                    this.y = height - this.radius;
                    this.oldY = this.y + (this.y - this.oldY) * 0.5;
                }
            }
        }

        // ============================================================
        // CONSTRAINTS
        // ============================================================

        class DistanceConstraint {
            constructor(p1, p2, restLength = null) {
                this.p1 = p1;
                this.p2 = p2;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                this.restLength = restLength !== null ? restLength : Math.sqrt(dx * dx + dy * dy);
            }

            solve(stiffness = 1.0) {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.001) return;

                const diff = (dist - this.restLength) / dist;
                const offsetX = dx * diff * 0.5 * stiffness;
                const offsetY = dy * diff * 0.5 * stiffness;

                if (!this.p1.pinned) {
                    this.p1.x += offsetX;
                    this.p1.y += offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x -= offsetX;
                    this.p2.y -= offsetY;
                }

                return Math.abs(dist - this.restLength) / this.restLength;
            }

            getStress() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return Math.abs(dist - this.restLength) / this.restLength;
            }
        }

        class CircleObstacle {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
            }

            constrain(point) {
                const dx = point.x - this.x;
                const dy = point.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.radius + point.radius) {
                    const pushDist = this.radius + point.radius - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;

                    point.x += nx * pushDist;
                    point.y += ny * pushDist;

                    // Dampen velocity
                    const vx = point.x - point.oldX;
                    const vy = point.y - point.oldY;
                    point.oldX = point.x - vx * 0.5;
                    point.oldY = point.y - vy * 0.5;
                }
            }
        }

        // ============================================================
        // PRESET FACTORY
        // ============================================================

        class PresetFactory {
            static createCloth(x, y, width, height, segments) {
                const points = [];
                const constraints = [];
                const dx = width / segments;
                const dy = height / segments;

                // Create grid of points
                for (let row = 0; row <= segments; row++) {
                    for (let col = 0; col <= segments; col++) {
                        const px = x + col * dx;
                        const py = y + row * dy;
                        const point = new VerletPoint(px, py, 1.0);

                        // Pin top row
                        if (row === 0) {
                            point.pinned = true;
                        }

                        points.push(point);
                    }
                }

                // Create constraints
                for (let row = 0; row <= segments; row++) {
                    for (let col = 0; col <= segments; col++) {
                        const idx = row * (segments + 1) + col;

                        // Horizontal
                        if (col < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + 1]));
                        }

                        // Vertical
                        if (row < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + segments + 1]));
                        }

                        // Diagonal (shear resistance)
                        if (col < segments && row < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + segments + 2]));
                            constraints.push(new DistanceConstraint(points[idx + 1], points[idx + segments + 1]));
                        }
                    }
                }

                return { points, constraints };
            }

            static createRope(x, y, length, segments) {
                const points = [];
                const constraints = [];
                const segmentLength = length / segments;

                // Create chain
                for (let i = 0; i <= segments; i++) {
                    const point = new VerletPoint(x, y + i * segmentLength, 1.0);
                    if (i === 0) {
                        point.pinned = true;
                    }
                    points.push(point);
                }

                // Distance constraints
                for (let i = 0; i < segments; i++) {
                    constraints.push(new DistanceConstraint(points[i], points[i + 1]));
                }

                return { points, constraints };
            }

            static createChain(x, y, length, segments) {
                const result = this.createRope(x, y, length, segments);

                // Add bend resistance (skip every other to make rigid segments)
                for (let i = 0; i < result.points.length - 2; i++) {
                    if (i % 2 === 0) {
                        result.constraints.push(new DistanceConstraint(result.points[i], result.points[i + 2]));
                    }
                }

                return result;
            }

            static createJello(x, y, size, segments) {
                const points = [];
                const constraints = [];
                const dx = size / segments;
                const dy = size / segments;

                // Create grid
                for (let row = 0; row <= segments; row++) {
                    for (let col = 0; col <= segments; col++) {
                        const px = x + col * dx;
                        const py = y + row * dy;
                        points.push(new VerletPoint(px, py, 1.0));
                    }
                }

                // Constraints (all directions for rigidity)
                for (let row = 0; row <= segments; row++) {
                    for (let col = 0; col <= segments; col++) {
                        const idx = row * (segments + 1) + col;

                        if (col < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + 1]));
                        }
                        if (row < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + segments + 1]));
                        }
                        if (col < segments && row < segments) {
                            constraints.push(new DistanceConstraint(points[idx], points[idx + segments + 2]));
                            constraints.push(new DistanceConstraint(points[idx + 1], points[idx + segments + 1]));
                        }
                    }
                }

                return { points, constraints };
            }

            static createRagdoll(x, y, scale = 1) {
                const points = [];
                const constraints = [];

                // Head
                const head = new VerletPoint(x, y, 2.0);
                head.radius = 8 * scale;
                points.push(head);

                // Upper body
                const neck = new VerletPoint(x, y + 15 * scale, 1.5);
                const chest = new VerletPoint(x, y + 35 * scale, 2.0);
                const waist = new VerletPoint(x, y + 55 * scale, 1.5);
                points.push(neck, chest, waist);

                // Arms
                const lShoulder = new VerletPoint(x - 20 * scale, y + 25 * scale, 1.0);
                const lElbow = new VerletPoint(x - 35 * scale, y + 40 * scale, 1.0);
                const lHand = new VerletPoint(x - 50 * scale, y + 55 * scale, 0.8);

                const rShoulder = new VerletPoint(x + 20 * scale, y + 25 * scale, 1.0);
                const rElbow = new VerletPoint(x + 35 * scale, y + 40 * scale, 1.0);
                const rHand = new VerletPoint(x + 50 * scale, y + 55 * scale, 0.8);

                points.push(lShoulder, lElbow, lHand, rShoulder, rElbow, rHand);

                // Legs
                const lHip = new VerletPoint(x - 10 * scale, y + 65 * scale, 1.5);
                const lKnee = new VerletPoint(x - 15 * scale, y + 90 * scale, 1.5);
                const lFoot = new VerletPoint(x - 10 * scale, y + 115 * scale, 1.0);

                const rHip = new VerletPoint(x + 10 * scale, y + 65 * scale, 1.5);
                const rKnee = new VerletPoint(x + 15 * scale, y + 90 * scale, 1.5);
                const rFoot = new VerletPoint(x + 10 * scale, y + 115 * scale, 1.0);

                points.push(lHip, lKnee, lFoot, rHip, rKnee, rFoot);

                // Pin head
                head.pinned = true;

                // Spine
                constraints.push(new DistanceConstraint(head, neck));
                constraints.push(new DistanceConstraint(neck, chest));
                constraints.push(new DistanceConstraint(chest, waist));

                // Left arm
                constraints.push(new DistanceConstraint(chest, lShoulder));
                constraints.push(new DistanceConstraint(lShoulder, lElbow));
                constraints.push(new DistanceConstraint(lElbow, lHand));

                // Right arm
                constraints.push(new DistanceConstraint(chest, rShoulder));
                constraints.push(new DistanceConstraint(rShoulder, rElbow));
                constraints.push(new DistanceConstraint(rElbow, rHand));

                // Left leg
                constraints.push(new DistanceConstraint(waist, lHip));
                constraints.push(new DistanceConstraint(lHip, lKnee));
                constraints.push(new DistanceConstraint(lKnee, lFoot));

                // Right leg
                constraints.push(new DistanceConstraint(waist, rHip));
                constraints.push(new DistanceConstraint(rHip, rKnee));
                constraints.push(new DistanceConstraint(rKnee, rFoot));

                // Stability constraints
                constraints.push(new DistanceConstraint(lShoulder, rShoulder));
                constraints.push(new DistanceConstraint(lHip, rHip));
                constraints.push(new DistanceConstraint(neck, waist));

                return { points, constraints };
            }

            static createBridge(x, y, width, segments) {
                const points = [];
                const constraints = [];
                const dx = width / segments;

                // Create chain
                for (let i = 0; i <= segments; i++) {
                    const point = new VerletPoint(x + i * dx, y, 1.5);

                    // Pin ends
                    if (i === 0 || i === segments) {
                        point.pinned = true;
                    }

                    points.push(point);
                }

                // Distance constraints
                for (let i = 0; i < segments; i++) {
                    constraints.push(new DistanceConstraint(points[i], points[i + 1]));
                }

                // Stability (skip constraints)
                for (let i = 0; i < segments - 1; i++) {
                    constraints.push(new DistanceConstraint(points[i], points[i + 2]));
                }

                return { points, constraints };
            }

            static createHair(x, y, strands, strandLength, segments) {
                const points = [];
                const constraints = [];
                const strandSpacing = 15;
                const segmentLength = strandLength / segments;

                for (let strand = 0; strand < strands; strand++) {
                    const startX = x + (strand - strands / 2) * strandSpacing;
                    const strandPoints = [];

                    // Create strand
                    for (let i = 0; i <= segments; i++) {
                        const point = new VerletPoint(startX, y + i * segmentLength, 0.5);
                        if (i === 0) {
                            point.pinned = true;
                        }
                        strandPoints.push(point);
                        points.push(point);
                    }

                    // Strand constraints
                    for (let i = 0; i < segments; i++) {
                        constraints.push(new DistanceConstraint(strandPoints[i], strandPoints[i + 1]));
                    }
                }

                return { points, constraints };
            }
        }

        // ============================================================
        // MAIN APPLICATION
        // ============================================================

        class VerletSimulation {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.points = [];
                this.constraints = [];
                this.obstacles = [];
                this.spatialHash = new SpatialHash(50);

                this.dt = 1 / 60;
                this.gravity = 9.8;
                this.damping = 0.99;
                this.iterations = 5;
                this.stiffness = 1.0;

                this.currentTool = 'grab';
                this.grabbedPoint = null;
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseDown = false;
                this.dragStart = null;

                this.paused = false;
                this.showPoints = true;
                this.showConstraints = true;
                this.showStress = true;
                this.showGrid = false;

                this.fps = 0;
                this.frameCount = 0;
                this.lastFrameTime = 0;
                this.collisionChecks = 0;

                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.loadPreset('cloth');
                this.animate();
            }

            setupCanvas() {
                const resize = () => {
                    const container = this.canvas.parentElement;
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                };
                resize();
                window.addEventListener('resize', resize);
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMouseDown(touch);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMouseMove(touch);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleMouseUp(e);
                });

                // Controls
                document.getElementById('presetSelect').addEventListener('change', (e) => {
                    this.loadPreset(e.target.value);
                });

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        document.getElementById('currentToolStat').textContent = btn.textContent;
                    });
                });

                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.points = [];
                    this.constraints = [];
                    this.obstacles = [];
                });

                document.getElementById('shakeBtn').addEventListener('click', () => {
                    this.shake();
                });

                document.getElementById('pauseBtn').addEventListener('click', (e) => {
                    this.paused = !this.paused;
                    e.target.textContent = this.paused ? 'Resume' : 'Pause';
                });

                // Sliders
                document.getElementById('gravity').addEventListener('input', (e) => {
                    this.gravity = parseFloat(e.target.value);
                    document.getElementById('gravityValue').textContent = this.gravity.toFixed(1);
                });

                document.getElementById('iterations').addEventListener('input', (e) => {
                    this.iterations = parseInt(e.target.value);
                    document.getElementById('iterationsValue').textContent = this.iterations;
                    document.getElementById('iterationsStat').textContent = this.iterations;
                });

                document.getElementById('damping').addEventListener('input', (e) => {
                    this.damping = parseFloat(e.target.value);
                    document.getElementById('dampingValue').textContent = this.damping.toFixed(3);
                });

                document.getElementById('stiffness').addEventListener('input', (e) => {
                    this.stiffness = parseFloat(e.target.value);
                    document.getElementById('stiffnessValue').textContent = this.stiffness.toFixed(2);
                });

                // Checkboxes
                document.getElementById('showPoints').addEventListener('change', (e) => {
                    this.showPoints = e.target.checked;
                });

                document.getElementById('showConstraints').addEventListener('change', (e) => {
                    this.showConstraints = e.target.checked;
                });

                document.getElementById('showStress').addEventListener('change', (e) => {
                    this.showStress = e.target.checked;
                });

                document.getElementById('showGrid').addEventListener('change', (e) => {
                    this.showGrid = e.target.checked;
                });
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX || e.pageX) - rect.left,
                    y: (e.clientY || e.pageY) - rect.top
                };
            }

            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.mouseX = pos.x;
                this.mouseY = pos.y;
                this.mouseDown = true;

                // Larger touch targets on mobile
                const isMobile = this.canvas.width < 768;
                const grabRadius = isMobile ? 40 : 20;
                const pinRadius = isMobile ? 30 : 15;
                const cutRadius = isMobile ? 20 : 10;

                switch (this.currentTool) {
                    case 'grab':
                        this.grabbedPoint = this.findNearestPoint(pos.x, pos.y, grabRadius);
                        break;
                    case 'pin':
                        const pinPoint = this.findNearestPoint(pos.x, pos.y, pinRadius);
                        if (pinPoint) {
                            pinPoint.pinned = !pinPoint.pinned;
                        }
                        break;
                    case 'cut':
                        this.cutNearestConstraint(pos.x, pos.y, cutRadius);
                        break;
                    case 'circle':
                        this.dragStart = { x: pos.x, y: pos.y };
                        break;
                }
            }

            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                this.mouseX = pos.x;
                this.mouseY = pos.y;

                if (this.currentTool === 'grab' && this.grabbedPoint) {
                    this.grabbedPoint.x = pos.x;
                    this.grabbedPoint.y = pos.y;
                    this.grabbedPoint.oldX = pos.x;
                    this.grabbedPoint.oldY = pos.y;
                }
            }

            handleMouseUp(e) {
                if (this.currentTool === 'circle' && this.dragStart && this.mouseDown) {
                    const dx = this.mouseX - this.dragStart.x;
                    const dy = this.mouseY - this.dragStart.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);

                    if (radius > 10) {
                        this.obstacles.push(new CircleObstacle(this.dragStart.x, this.dragStart.y, radius));
                    }
                }

                this.mouseDown = false;
                this.grabbedPoint = null;
                this.dragStart = null;
            }

            findNearestPoint(x, y, maxDist) {
                let nearest = null;
                let minDist = maxDist;

                for (const point of this.points) {
                    const dx = point.x - x;
                    const dy = point.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < minDist) {
                        minDist = dist;
                        nearest = point;
                    }
                }

                return nearest;
            }

            cutNearestConstraint(x, y, maxDist) {
                let nearest = null;
                let minDist = maxDist;

                for (const constraint of this.constraints) {
                    const dist = this.distanceToSegment(x, y, constraint.p1.x, constraint.p1.y, constraint.p2.x, constraint.p2.y);

                    if (dist < minDist) {
                        minDist = dist;
                        nearest = constraint;
                    }
                }

                if (nearest) {
                    const idx = this.constraints.indexOf(nearest);
                    this.constraints.splice(idx, 1);
                }
            }

            distanceToSegment(px, py, x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const lengthSq = dx * dx + dy * dy;

                if (lengthSq === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));

                let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
                t = Math.max(0, Math.min(1, t));

                const projX = x1 + t * dx;
                const projY = y1 + t * dy;

                return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
            }

            shake() {
                for (const point of this.points) {
                    if (!point.pinned) {
                        const force = 500;
                        point.forceX += (Math.random() - 0.5) * force;
                        point.forceY += (Math.random() - 0.5) * force;
                    }
                }
            }

            loadPreset(preset) {
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 3;

                // Scale for mobile
                const isMobile = this.canvas.width < 768;
                const scale = isMobile ? 0.6 : 1.0;
                const segmentScale = isMobile ? 0.7 : 1.0;

                let result;
                switch (preset) {
                    case 'cloth':
                        result = PresetFactory.createCloth(
                            cx - 150 * scale,
                            cy - 100 * scale,
                            300 * scale,
                            250 * scale,
                            Math.floor(15 * segmentScale)
                        );
                        break;
                    case 'rope':
                        result = PresetFactory.createRope(
                            cx,
                            cy - 150 * scale,
                            300 * scale,
                            Math.floor(20 * segmentScale)
                        );
                        break;
                    case 'chain':
                        result = PresetFactory.createChain(
                            cx,
                            cy - 150 * scale,
                            300 * scale,
                            Math.floor(15 * segmentScale)
                        );
                        break;
                    case 'jello':
                        result = PresetFactory.createJello(
                            cx - 100 * scale,
                            cy - 100 * scale,
                            200 * scale,
                            Math.floor(10 * segmentScale)
                        );
                        break;
                    case 'ragdoll':
                        result = PresetFactory.createRagdoll(cx, cy - 50 * scale, 1.2 * scale);
                        break;
                    case 'bridge':
                        result = PresetFactory.createBridge(
                            cx - 200 * scale,
                            cy,
                            400 * scale,
                            Math.floor(25 * segmentScale)
                        );
                        break;
                    case 'hair':
                        result = PresetFactory.createHair(
                            cx,
                            cy - 150 * scale,
                            isMobile ? 5 : 8,
                            200 * scale,
                            Math.floor(15 * segmentScale)
                        );
                        break;
                }

                this.points = result.points;
                this.constraints = result.constraints;
                this.obstacles = [];
            }

            update() {
                if (this.paused) return;

                // Update points
                for (const point of this.points) {
                    point.update(this.dt, this.damping, this.gravity);
                }

                // Solve constraints
                for (let i = 0; i < this.iterations; i++) {
                    for (const constraint of this.constraints) {
                        constraint.solve(this.stiffness);
                    }
                }

                // Boundary constraints
                for (const point of this.points) {
                    point.constrain(this.canvas.width, this.canvas.height);
                }

                // Obstacle collisions
                for (const obstacle of this.obstacles) {
                    for (const point of this.points) {
                        obstacle.constrain(point);
                    }
                }

                // Point-to-point collisions (using spatial hash)
                this.collisionChecks = 0;
                this.spatialHash.clear();

                for (const point of this.points) {
                    this.spatialHash.insert(point);
                }

                for (const point of this.points) {
                    const nearby = this.spatialHash.query(point.x, point.y, point.radius * 4);

                    for (const other of nearby) {
                        if (point === other) continue;
                        this.collisionChecks++;

                        const dx = other.x - point.x;
                        const dy = other.y - point.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = point.radius + other.radius;

                        if (dist < minDist && dist > 0.001) {
                            const push = (minDist - dist) * 0.5;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            if (!point.pinned) {
                                point.x -= nx * push;
                                point.y -= ny * push;
                            }
                            if (!other.pinned) {
                                other.x += nx * push;
                                other.y += ny * push;
                            }
                        }
                    }
                }

                // Update stats
                document.getElementById('pointCount').textContent = this.points.length;
                document.getElementById('constraintCount').textContent = this.constraints.length;
                document.getElementById('collisionsStat').textContent = this.collisionChecks;
                document.getElementById('hashCellsStat').textContent = this.spatialHash.getCellCount();
            }

            render() {
                const { width, height } = this.canvas;

                // Clear
                this.ctx.fillStyle = '#080a08';
                this.ctx.fillRect(0, 0, width, height);

                // Grid
                if (this.showGrid) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 65, 0.08)';
                    this.ctx.lineWidth = 1;
                    const gridSize = 50;

                    for (let x = 0; x < width; x += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, height);
                        this.ctx.stroke();
                    }
                    for (let y = 0; y < height; y += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(width, y);
                        this.ctx.stroke();
                    }
                }

                // Constraints
                if (this.showConstraints) {
                    for (const constraint of this.constraints) {
                        const stress = constraint.getStress();
                        this.ctx.strokeStyle = getStressColor(stress, this.showStress);
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(constraint.p1.x, constraint.p1.y);
                        this.ctx.lineTo(constraint.p2.x, constraint.p2.y);
                        this.ctx.stroke();
                    }
                }

                // Points
                if (this.showPoints) {
                    for (const point of this.points) {
                        if (point.pinned) {
                            // Pinned points - yellow with outline
                            this.ctx.fillStyle = '#ffff00';
                            this.ctx.strokeStyle = '#00ff41';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.stroke();
                        } else {
                            // Normal points
                            this.ctx.fillStyle = '#00ff41';
                            this.ctx.beginPath();
                            this.ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }

                // Obstacles
                for (const obstacle of this.obstacles) {
                    this.ctx.strokeStyle = '#00ff41';
                    this.ctx.fillStyle = 'rgba(0, 255, 65, 0.1)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                }

                // Draw circle preview
                if (this.currentTool === 'circle' && this.dragStart && this.mouseDown) {
                    const dx = this.mouseX - this.dragStart.x;
                    const dy = this.mouseY - this.dragStart.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);

                    this.ctx.strokeStyle = 'rgba(0, 255, 65, 0.5)';
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(this.dragStart.x, this.dragStart.y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            animate(timestamp = 0) {
                // FPS calculation
                this.frameCount++;
                if (timestamp - this.lastFrameTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFrameTime = timestamp;
                    document.getElementById('fps').textContent = this.fps;
                }

                this.update();
                this.render();

                requestAnimationFrame((t) => this.animate(t));
            }
        }

        // Initialize
        const simulation = new VerletSimulation();
    </script>
</body>
</html>
