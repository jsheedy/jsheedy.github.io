<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z-Order Spatial Query</title>
    <link rel="stylesheet" href="styles/terminal-theme.css">
    <style>

        #canvas {
            display: block;
            background: #000;
            flex: 1;
            width: 100%;
            cursor: crosshair;
            box-shadow: inset 0 0 100px rgba(0, 255, 65, 0.05);
        }

        .control-panel {
            max-height: 200px;
            overflow-y: auto;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-panel {
            grid-column: span 1;
        }

        .info-panel {
            grid-column: span 1;
            background: #001a00;
            border: 1px solid #00ff41;
            padding: 10px;
            font-size: 9px;
            line-height: 1.4;
            color: #00ff4199;
            box-shadow: inset 0 0 10px rgba(0, 255, 65, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .info-panel h3 {
            color: #00ff41;
            font-size: 10px;
            margin: 0 0 5px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #00ff41;
        }

        .info-panel .info-line {
            margin: 2px 0;
            color: rgba(0, 255, 65, 0.7);
        }

        #canvas {
            animation: flicker 0.15s infinite;
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <a href="index.html" class="back-link">Experiments</a>
        <div class="title-text">Z-ORDER SPATIAL QUERY</div>
        <div class="title-subtitle">EXPLORE SPATIAL LOCALITY WITH Z-CODE RANGES</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="control-panel">
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="gridSize">16x16</div>
                <div class="stat-label">Grid Size</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="hoveredCode">-</div>
                <div class="stat-label">Hovered Z-Code</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="highlightedCount">0</div>
                <div class="stat-label">Highlighted Count</div>
            </div>
        </div>

        <div class="control-group">
            <label>Grid Depth: <span class="value-display" id="depthDisplay">4</span></label>
            <input type="range" id="depth" min="1" max="8" value="4" step="1">
        </div>

        <div class="control-group">
            <label>Z-Code Range: <span class="value-display" id="rangeDisplay">±20</span></label>
            <input type="range" id="rangeSlider" min="0" max="100" value="20" step="1">
        </div>

        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="showCodes" checked>
                Show Z-Codes
            </label>
        </div>

        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="showCoords">
                Show Coordinates
            </label>
        </div>

        <div class="control-group">
            <button onclick="togglePathAnimation()">Animate Z-Order Path</button>
        </div>

        <div class="help-panel">
            <h3>About</h3>
            <p>Interactive Z-order spatial query visualization demonstrating spatial locality in Morton curves.</p>
            <p>Hover over grid cells to query their Z-code neighbors. The Z-order column shows the 1D array mapping.</p>
            <p>Z-order encoding preserves 2D spatial proximity in 1D space for efficient neighbor searches.</p>
        </div>

        <div class="info-panel" id="infoPanel">
            <h3>Spatial Query</h3>
            <div class="info-line" id="queryInfo">Hover over a cell to query</div>
        </div>
    </div>

    <script type="module">
        import { ZOrder } from './js/spatial-partitioning.js';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const titleBar = document.querySelector('.title-bar');
            const controlPanel = document.querySelector('.control-panel');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - titleBar.offsetHeight - controlPanel.offsetHeight;
            generateGrid();
            draw();
        }

        // Wait for DOM to be fully loaded before initial resize
        window.addEventListener('load', () => {
            resizeCanvas();
        });
        window.addEventListener('resize', resizeCanvas);

        // Grid cell class
        class GridCell {
            constructor(gridX, gridY, zCode, screenX, screenY, cellSize) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.zCode = zCode;
                this.screenX = screenX;
                this.screenY = screenY;
                this.cellSize = cellSize;
            }

            draw(ctx, showCodes, showCoords, isHighlighted = false, isHovered = false) {
                const x = this.screenX;
                const y = this.screenY;
                const size = this.cellSize;

                // Draw cell background
                if (isHovered) {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.5)';
                } else if (isHighlighted) {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.2)';
                } else {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                }
                ctx.fillRect(x, y, size, size);

                // Draw cell border
                ctx.strokeStyle = isHovered ? '#00ff41' : 'rgba(0, 255, 65, 0.6)';
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.strokeRect(x, y, size, size);

                // Calculate font size based on cell size
                const fontSize = Math.max(10, Math.min(size / 4, 14));
                ctx.font = `${fontSize}px 'Courier New', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw Z-code
                if (showCodes) {
                    ctx.fillStyle = isHovered ? '#00ff41' : 'rgba(0, 255, 65, 0.8)';
                    ctx.fillText(this.zCode.toString(), x + size / 2, y + size / 2);
                }

                // Draw coordinates
                if (showCoords) {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.5)';
                    ctx.font = `${Math.max(8, fontSize - 2)}px 'Courier New', monospace`;
                    const coordText = `(${this.gridX},${this.gridY})`;
                    const yOffset = showCodes ? size * 0.7 : size / 2;
                    ctx.fillText(coordText, x + size / 2, y + yOffset);
                }

                // Draw hover indicator
                if (isHovered) {
                    ctx.fillStyle = '#00ff41';
                    ctx.font = `bold ${Math.max(8, fontSize - 2)}px 'Courier New', monospace`;
                    ctx.textAlign = 'left';
                    ctx.fillText('⬤', x + 5, y + fontSize);
                }
            }

            contains(mouseX, mouseY) {
                return mouseX >= this.screenX &&
                       mouseX <= this.screenX + this.cellSize &&
                       mouseY >= this.screenY &&
                       mouseY <= this.screenY + this.cellSize;
            }
        }

        // State
        let depth = 4;
        let range = 20;
        let showCodes = true;
        let showCoords = false;
        let cells = [];
        let hoveredCell = null;
        let zColumnWidth = 60; // Width of the Z-code column on the right
        let gridToColumnGap = 15; // Gap between grid and column
        let axisLabelSpace = 20; // Space for axis labels

        // Path animation state
        let pathPoints = [];
        let currentStep = 0;
        let frameCounter = 0;
        let isAnimating = false;
        let animSpeed = 20; // Fixed speed

        // Generate grid cells
        function generateGrid() {
            cells = [];
            pathPoints = [];
            currentStep = 0;

            const cellsPerSide = 1 << depth; // 2^depth
            const totalWidth = canvas.width - axisLabelSpace - 40; // Leave space for y-axis labels
            const totalHeight = canvas.height - axisLabelSpace - 40; // Leave space for x-axis labels
            const gridSize = Math.min(totalWidth - zColumnWidth - gridToColumnGap, totalHeight);
            const cellSize = gridSize / cellsPerSide;

            // Center the combined grid + gap + column
            const combinedWidth = gridSize + gridToColumnGap + zColumnWidth;
            const offsetX = (canvas.width - combinedWidth) / 2 + axisLabelSpace;
            const offsetY = (canvas.height - gridSize) / 2;

            // Generate all cells with their Z-codes
            const cellMap = [];
            for (let y = 0; y < cellsPerSide; y++) {
                for (let x = 0; x < cellsPerSide; x++) {
                    const zCode = ZOrder.encode(x, y);
                    const screenX = offsetX + x * cellSize;
                    const screenY = offsetY + y * cellSize;
                    const cell = new GridCell(x, y, zCode, screenX, screenY, cellSize);
                    cellMap.push(cell);
                }
            }

            // Sort by Z-order
            cellMap.sort((a, b) => a.zCode - b.zCode);
            cells = cellMap;

            // Generate path points for animation
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                pathPoints.push({
                    x: cell.screenX + cell.cellSize / 2,
                    y: cell.screenY + cell.cellSize / 2,
                    order: i
                });
            }

            // Update stats
            document.getElementById('gridSize').textContent = `${cellsPerSide}x${cellsPerSide}`;
        }

        // Draw everything
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Determine which cells to highlight
            let highlightedCells = new Set();
            if (hoveredCell) {
                const minZ = hoveredCell.zCode - range;
                const maxZ = hoveredCell.zCode + range;

                for (let cell of cells) {
                    if (cell.zCode >= minZ && cell.zCode <= maxZ && cell !== hoveredCell) {
                        highlightedCells.add(cell);
                    }
                }
            }

            // Draw cells
            for (let cell of cells) {
                const isHovered = cell === hoveredCell;
                const isHighlighted = highlightedCells.has(cell);
                cell.draw(ctx, showCodes, showCoords, isHighlighted, isHovered);
            }

            // Draw animated path if active
            if (isAnimating) {
                drawPath(currentStep);
            }

            // Draw Z-code column
            drawZCodeColumn(highlightedCells);

            // Draw axis labels
            drawAxisLabels();

            // Update stats
            if (hoveredCell) {
                document.getElementById('hoveredCode').textContent = hoveredCell.zCode;
                document.getElementById('highlightedCount').textContent = highlightedCells.size;
            } else {
                document.getElementById('hoveredCode').textContent = '-';
                document.getElementById('highlightedCount').textContent = '0';
            }

            // Draw legend
            drawLegend();
        }

        // Draw the Z-order path
        function drawPath(upToStep = -1) {
            if (pathPoints.length < 2) return;

            const endStep = upToStep >= 0 ? Math.min(upToStep, pathPoints.length - 1) : pathPoints.length - 1;

            // Draw path line
            ctx.strokeStyle = 'rgba(0, 255, 65, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(pathPoints[0].x, pathPoints[0].y);

            for (let i = 1; i <= endStep; i++) {
                ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
            }

            ctx.stroke();

            // Draw arrow at the current position
            if (endStep > 0 && endStep < pathPoints.length - 1) {
                const curr = pathPoints[endStep];
                const prev = pathPoints[endStep - 1];
                const angle = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const arrowSize = 10;

                ctx.fillStyle = '#00ff41';
                ctx.beginPath();
                ctx.moveTo(curr.x, curr.y);
                ctx.lineTo(
                    curr.x - arrowSize * Math.cos(angle - Math.PI / 6),
                    curr.y - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    curr.x - arrowSize * Math.cos(angle + Math.PI / 6),
                    curr.y - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }

            // Draw start marker
            ctx.fillStyle = 'rgba(0, 255, 65, 0.8)';
            ctx.beginPath();
            ctx.arc(pathPoints[0].x, pathPoints[0].y, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw end marker if path is complete
            if (endStep >= pathPoints.length - 1) {
                ctx.fillStyle = '#00ff41';
                ctx.beginPath();
                ctx.arc(pathPoints[pathPoints.length - 1].x, pathPoints[pathPoints.length - 1].y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw axis labels
        function drawAxisLabels() {
            if (cells.length === 0) return;

            const cellsPerSide = 1 << depth;
            const totalWidth = canvas.width - axisLabelSpace - 40;
            const totalHeight = canvas.height - axisLabelSpace - 40;
            const gridSize = Math.min(totalWidth - zColumnWidth - gridToColumnGap, totalHeight);
            const cellSize = gridSize / cellsPerSide;

            const combinedWidth = gridSize + gridToColumnGap + zColumnWidth;
            const offsetX = (canvas.width - combinedWidth) / 2 + axisLabelSpace;
            const offsetY = (canvas.height - gridSize) / 2;

            // Determine label skip interval based on depth
            let skipInterval = 1;
            if (depth >= 8) {
                skipInterval = 32;
            } else if (depth >= 7) {
                skipInterval = 16;
            }

            ctx.fillStyle = 'rgba(0, 255, 65, 0.6)';
            ctx.font = "10px 'Courier New', monospace";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // X-axis labels (top of grid)
            for (let x = 0; x < cellsPerSide; x++) {
                if (x % skipInterval === 0) {
                    const labelX = offsetX + x * cellSize + cellSize / 2;
                    const labelY = offsetY - 8;
                    ctx.fillText(x.toString(), labelX, labelY);
                }
            }

            // Y-axis labels (left of grid)
            ctx.textAlign = 'right';
            for (let y = 0; y < cellsPerSide; y++) {
                if (y % skipInterval === 0) {
                    const labelX = offsetX - 8;
                    const labelY = offsetY + y * cellSize + cellSize / 2;
                    ctx.fillText(y.toString(), labelX, labelY);
                }
            }
        }

        // Draw the Z-code column visualization
        function drawZCodeColumn(highlightedCells) {
            if (cells.length === 0) return;

            const cellsPerSide = 1 << depth;
            const totalWidth = canvas.width - axisLabelSpace - 40;
            const totalHeight = canvas.height - axisLabelSpace - 40;
            const gridSize = Math.min(totalWidth - zColumnWidth - gridToColumnGap, totalHeight);

            // Center the combined grid + gap + column
            const combinedWidth = gridSize + gridToColumnGap + zColumnWidth;
            const offsetX = (canvas.width - combinedWidth) / 2 + axisLabelSpace;
            const offsetY = (canvas.height - gridSize) / 2;

            const columnX = offsetX + gridSize + gridToColumnGap;
            const columnY = offsetY;
            const columnHeight = gridSize;
            const cellHeight = columnHeight / cells.length;

            // Draw column background
            ctx.fillStyle = 'rgba(0, 255, 65, 0.05)';
            ctx.fillRect(columnX, columnY, zColumnWidth, columnHeight);
            ctx.strokeStyle = 'rgba(0, 255, 65, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(columnX, columnY, zColumnWidth, columnHeight);

            // Draw each Z-code as a small box
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                const y = columnY + i * cellHeight;
                const isHovered = cell === hoveredCell;
                const isHighlighted = highlightedCells.has(cell);

                // Draw cell background
                if (isHovered) {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.8)';
                } else if (isHighlighted) {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.4)';
                } else {
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.1)';
                }
                ctx.fillRect(columnX, y, zColumnWidth, cellHeight);

                // Draw separator line
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(columnX, y);
                ctx.lineTo(columnX + zColumnWidth, y);
                ctx.stroke();

                // Draw Z-code text for hovered or if cell is large enough
                if (isHovered || cellHeight > 12) {
                    ctx.fillStyle = isHovered ? '#00ff41' : 'rgba(0, 255, 65, 0.6)';
                    ctx.font = `${Math.min(10, cellHeight - 2)}px 'Courier New', monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cell.zCode.toString(), columnX + zColumnWidth / 2, y + cellHeight / 2);
                }
            }

            // Draw label
            ctx.fillStyle = '#00ff41';
            ctx.font = "10px 'Courier New', monospace";
            ctx.textAlign = 'center';
            ctx.fillText('Z-ORDER', columnX + zColumnWidth / 2, columnY - 10);
        }

        // Draw legend
        function drawLegend() {
            const padding = 20;
            const lineHeight = 20;
            let y = padding;

            ctx.font = "12px 'Courier New', monospace";
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            // Title
            ctx.fillStyle = '#00ff41';
            ctx.fillText('SPATIAL QUERY', padding, y);
            y += lineHeight * 1.5;

            // Info
            ctx.fillStyle = 'rgba(0, 255, 65, 0.7)';
            if (hoveredCell) {
                ctx.fillText(`Hover Z-Code: ${hoveredCell.zCode}`, padding, y);
                y += lineHeight;
                ctx.fillText(`Grid Pos: (${hoveredCell.gridX}, ${hoveredCell.gridY})`, padding, y);
                y += lineHeight;
                ctx.fillText(`Query Range: [${hoveredCell.zCode - range}, ${hoveredCell.zCode + range}]`, padding, y);
                y += lineHeight;

                // Count highlighted cells
                let highlightedCount = 0;
                const minZ = hoveredCell.zCode - range;
                const maxZ = hoveredCell.zCode + range;
                for (let cell of cells) {
                    if (cell.zCode >= minZ && cell.zCode <= maxZ && cell !== hoveredCell) {
                        highlightedCount++;
                    }
                }
                ctx.fillText(`Highlighted Cells: ${highlightedCount}`, padding, y);
            } else {
                ctx.fillText('Hover over a cell to query', padding, y);
            }
        }

        // Mouse move handler
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            hoveredCell = null;
            for (let cell of cells) {
                if (cell.contains(mouseX, mouseY)) {
                    hoveredCell = cell;
                    break;
                }
            }

            draw();
        });

        // Mouse leave handler
        canvas.addEventListener('mouseleave', () => {
            hoveredCell = null;
            draw();
        });

        // Event listeners
        document.getElementById('depth').addEventListener('input', (e) => {
            depth = parseInt(e.target.value);
            document.getElementById('depthDisplay').textContent = depth;

            // Auto-disable Z-codes display for depth >= 6 (too many cells)
            if (depth >= 6 && showCodes) {
                showCodes = false;
                document.getElementById('showCodes').checked = false;
            }

            generateGrid();
            draw();
        });

        document.getElementById('rangeSlider').addEventListener('input', (e) => {
            range = parseInt(e.target.value);
            document.getElementById('rangeDisplay').textContent = `±${range}`;
            draw();
        });

        document.getElementById('showCodes').addEventListener('change', (e) => {
            showCodes = e.target.checked;
            draw();
        });

        document.getElementById('showCoords').addEventListener('change', (e) => {
            showCoords = e.target.checked;
            draw();
        });

        // Toggle path animation
        function togglePathAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                // Reset animation to start
                currentStep = 0;
                frameCounter = 0;
            }
        }

        // Animation loop
        function animate() {
            if (isAnimating) {
                frameCounter++;
                if (frameCounter >= (21 - animSpeed)) {
                    frameCounter = 0;
                    currentStep++;
                    if (currentStep >= cells.length) {
                        currentStep = 0;
                    }
                }
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Start animation loop
        requestAnimationFrame(animate);
    </script>
</body>
</html>
