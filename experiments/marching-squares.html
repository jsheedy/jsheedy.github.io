<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Marching Squares</title>
	<style>
		* { box-sizing: border-box; margin: 0; padding: 0; }
		html, body { height: 100%; overflow: hidden; }
		body {
			font-family: 'Courier New', monospace;
			background: #0a0e0a;
			color: #00ff41;
			display: flex;
			flex-direction: column;
		}

		.title-bar {
			background: linear-gradient(180deg, #1a2a1a 0%, #0f1e0f 100%);
			border-bottom: 3px solid #00ff41;
			padding: 12px 20px;
			box-shadow: 0 5px 30px rgba(0,255,65,0.25), inset 0 1px 0 rgba(0,255,65,0.15);
		}

		.title-text {
			font-size: 24px;
			letter-spacing: 6px;
			text-transform: uppercase;
			color: #00ff41;
			text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41;
			font-weight: bold;
			display: inline-block;
			margin-right: 20px;
		}

		.subtitle {
			font-size: 11px;
			color: #00ff4199;
			letter-spacing: 2px;
		}

		.controls {
			background: #001a00;
			border-bottom: 1px solid #00ff4133;
			padding: 12px 20px;
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 16px;
			font-size: 12px;
		}

		.control-group {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}

		.control-row {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		label {
			color: #00ff4199;
			font-size: 11px;
			text-transform: uppercase;
			letter-spacing: 1px;
			min-width: 90px;
		}

		input[type="range"] {
			flex: 1;
			height: 4px;
			background: #00ff4133;
			border: none;
			outline: none;
			-webkit-appearance: none;
		}

		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 14px;
			height: 14px;
			background: #00ff41;
			cursor: pointer;
			border-radius: 50%;
			box-shadow: 0 0 8px #00ff41;
		}

		input[type="range"]::-moz-range-thumb {
			width: 14px;
			height: 14px;
			background: #00ff41;
			cursor: pointer;
			border-radius: 50%;
			border: none;
			box-shadow: 0 0 8px #00ff41;
		}

		.value-display {
			color: #00ff41;
			font-weight: bold;
			min-width: 45px;
			text-align: right;
			font-size: 11px;
		}

		select, button {
			background: #001a00;
			color: #00ff41;
			border: 2px solid #00ff4133;
			padding: 4px 8px;
			font-family: inherit;
			font-size: 11px;
			border-radius: 3px;
			cursor: pointer;
		}

		button {
			border-color: #00ff41;
			text-transform: uppercase;
			letter-spacing: 1px;
			transition: all 0.15s;
		}

		button:hover {
			background: #00ff41;
			color: #001;
			box-shadow: 0 0 15px rgba(0,255,65,0.4);
		}

		button:active {
			transform: scale(0.97);
		}

		select:focus {
			outline: none;
			border-color: #00ff41;
		}

		input[type="checkbox"] {
			width: 16px;
			height: 16px;
			cursor: pointer;
		}

		.canvas-container {
			flex: 1;
			position: relative;
			overflow: hidden;
			touch-action: none;
			-webkit-user-select: none;
			user-select: none;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
			cursor: crosshair;
			touch-action: none;
		}

		.stats {
			position: absolute;
			top: 12px;
			right: 12px;
			background: rgba(0,26,0,0.85);
			border: 1px solid #00ff4133;
			padding: 10px 14px;
			font-size: 11px;
			line-height: 1.6;
			border-radius: 3px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.5);
		}

		.stats div {
			display: flex;
			justify-content: space-between;
			gap: 12px;
		}

		.stats .label {
			color: #00ff4199;
		}

		.stats .value {
			color: #00ff41;
			font-weight: bold;
		}

		.instructions {
			position: absolute;
			bottom: 12px;
			left: 12px;
			background: rgba(0,26,0,0.85);
			border: 1px solid #00ff4133;
			padding: 10px 14px;
			font-size: 11px;
			line-height: 1.6;
			border-radius: 3px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.5);
		}

		.instructions div {
			color: #00ff4199;
		}

		@keyframes scanline {
			0% { transform: translateY(-100%); }
			100% { transform: translateY(100%); }
		}

		.scanline {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 2px;
			background: linear-gradient(transparent, #00ff4133, transparent);
			pointer-events: none;
			animation: scanline 8s linear infinite;
		}

		/* Mobile optimizations */
		@media (max-width: 768px) {
			.title-text {
				font-size: 18px;
				letter-spacing: 3px;
			}

			.subtitle {
				font-size: 9px;
				letter-spacing: 2px;
			}

			.controls {
				padding: 8px 12px;
				gap: 12px;
				grid-template-columns: 1fr;
			}

			.control-row {
				gap: 8px;
			}

			label {
				font-size: 10px;
				min-width: 70px;
			}

			button, select {
				padding: 6px 10px;
				font-size: 10px;
			}

			.stats, .instructions {
				font-size: 10px;
				padding: 8px 10px;
			}

			input[type="range"]::-webkit-slider-thumb {
				width: 18px;
				height: 18px;
			}

			input[type="range"]::-moz-range-thumb {
				width: 18px;
				height: 18px;
			}
		}
	</style>
</head>
<body>
	<div class="title-bar">
		<span class="title-text">Marching Squares</span>
		<span class="subtitle">Contour generation & metaballs with implicit surfaces</span>
	</div>

	<div class="controls">
		<div class="control-group">
			<div class="control-row">
				<label>Preset</label>
				<select id="preset">
					<option value="metaballs">Metaballs</option>
					<option value="weather">Weather Map</option>
					<option value="terrain">Terrain</option>
					<option value="lava">Lava Lamp</option>
				</select>
			</div>
			<div class="control-row">
				<button id="btnClear">Clear Sources</button>
			</div>
		</div>

		<div class="control-group">
			<div class="control-row">
				<label>Grid Size</label>
				<input type="range" id="gridSize" min="10" max="80" value="40" step="5">
				<span class="value-display" id="gridSizeVal">40</span>
			</div>
			<div class="control-row">
				<label>Threshold</label>
				<input type="range" id="threshold" min="0.1" max="3" value="1" step="0.1">
				<span class="value-display" id="thresholdVal">1.0</span>
			</div>
		</div>

		<div class="control-group">
			<div class="control-row">
				<label>Strength</label>
				<input type="range" id="strength" min="100" max="10000" value="2000" step="100">
				<span class="value-display" id="strengthVal">2000</span>
			</div>
			<div class="control-row">
				<label>Levels</label>
				<input type="range" id="levels" min="1" max="8" value="3" step="1">
				<span class="value-display" id="levelsVal">3</span>
			</div>
		</div>

		<div class="control-group">
			<div class="control-row">
				<label><input type="checkbox" id="chkAnimate" checked> Animate</label>
				<label><input type="checkbox" id="chkShowGrid"> Grid</label>
			</div>
			<div class="control-row">
				<label><input type="checkbox" id="chkFilled"> Filled</label>
				<label><input type="checkbox" id="chkField" checked> Field</label>
			</div>
		</div>
	</div>

	<div class="canvas-container">
		<canvas id="canvas"></canvas>
		<div class="scanline"></div>

		<div class="stats">
			<div><span class="label">Sources:</span><span class="value" id="statSources">0</span></div>
			<div><span class="label">Grid:</span><span class="value" id="statGrid">40x40</span></div>
			<div><span class="label">FPS:</span><span class="value" id="statFps">60</span></div>
		</div>

		<div class="instructions">
			<div>CLICK to add source • DRAG to move • SHIFT+CLICK to remove</div>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');

		// Resize canvas
		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			canvas.width = rect.width;
			canvas.height = rect.height;
			computeField();
			render();
		}
		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		// Marching squares configuration lookup table
		const EDGE_TABLE = [
			[], // 0000
			[3, 0], // 0001
			[0, 1], // 0010
			[3, 1], // 0011
			[1, 2], // 0100
			[3, 0, 1, 2], // 0101 (ambiguous - split)
			[0, 2], // 0110
			[3, 2], // 0111
			[2, 3], // 1000
			[0, 2], // 1001
			[0, 1, 2, 3], // 1010 (ambiguous - split)
			[1, 2], // 1011
			[1, 3], // 1100
			[0, 1], // 1101
			[0, 3], // 1110
			[] // 1111
		];

		// State
		let sources = [];
		let field = null;
		let gridSize = 40;
		let threshold = 1.0;
		let strength = 2000;
		let levels = 3;
		let animate = true;
		let showGrid = false;
		let showFilled = false;
		let showField = true;
		let draggedSource = null;
		let lastFrameTime = 0;
		let fps = 60;

		// Scalar field evaluation
		function evaluateField(x, y) {
			let value = 0;
			for (const source of sources) {
				const dx = x - source.x;
				const dy = y - source.y;
				const distSq = dx * dx + dy * dy;
				value += source.strength / (1 + distSq * 0.001);
			}
			return value;
		}

		// Compute field values for all grid points
		function computeField() {
			const cols = gridSize;
			const rows = gridSize;
			field = new Array(rows + 1);

			const cellWidth = canvas.width / cols;
			const cellHeight = canvas.height / rows;

			for (let i = 0; i <= rows; i++) {
				field[i] = new Array(cols + 1);
				for (let j = 0; j <= cols; j++) {
					const x = j * cellWidth;
					const y = i * cellHeight;
					field[i][j] = evaluateField(x, y);
				}
			}
		}

		// Linear interpolation for edge intersection
		function interpolate(v1, v2, threshold) {
			if (Math.abs(v1 - v2) < 0.001) return 0.5;
			return (threshold - v1) / (v2 - v1);
		}

		// Get edge point
		function getEdgePoint(row, col, edge, threshold, cellWidth, cellHeight) {
			const x = col * cellWidth;
			const y = row * cellHeight;

			const v0 = field[row][col];
			const v1 = field[row][col + 1];
			const v2 = field[row + 1][col + 1];
			const v3 = field[row + 1][col];

			let px, py;

			switch (edge) {
				case 0: // Top edge
					const t0 = interpolate(v0, v1, threshold);
					px = x + t0 * cellWidth;
					py = y;
					break;
				case 1: // Right edge
					const t1 = interpolate(v1, v2, threshold);
					px = x + cellWidth;
					py = y + t1 * cellHeight;
					break;
				case 2: // Bottom edge
					const t2 = interpolate(v3, v2, threshold);
					px = x + t2 * cellWidth;
					py = y + cellHeight;
					break;
				case 3: // Left edge
					const t3 = interpolate(v0, v3, threshold);
					px = x;
					py = y + t3 * cellHeight;
					break;
			}

			return { x: px, y: py };
		}

		// March a single cell
		function marchCell(row, col, threshold, cellWidth, cellHeight) {
			const v0 = field[row][col];
			const v1 = field[row][col + 1];
			const v2 = field[row + 1][col + 1];
			const v3 = field[row + 1][col];

			// Calculate configuration index
			let config = 0;
			if (v0 > threshold) config |= 1;
			if (v1 > threshold) config |= 2;
			if (v2 > threshold) config |= 4;
			if (v3 > threshold) config |= 8;

			const edges = EDGE_TABLE[config];
			if (edges.length === 0) return [];

			const segments = [];

			// Handle ambiguous cases (5 and 10)
			if (config === 5 || config === 10) {
				// Split into two segments
				const p0 = getEdgePoint(row, col, edges[0], threshold, cellWidth, cellHeight);
				const p1 = getEdgePoint(row, col, edges[1], threshold, cellWidth, cellHeight);
				const p2 = getEdgePoint(row, col, edges[2], threshold, cellWidth, cellHeight);
				const p3 = getEdgePoint(row, col, edges[3], threshold, cellWidth, cellHeight);
				segments.push([p0, p1]);
				segments.push([p2, p3]);
			} else {
				// Normal case - pairs of edges
				for (let i = 0; i < edges.length; i += 2) {
					const p1 = getEdgePoint(row, col, edges[i], threshold, cellWidth, cellHeight);
					const p2 = getEdgePoint(row, col, edges[i + 1], threshold, cellWidth, cellHeight);
					segments.push([p1, p2]);
				}
			}

			return segments;
		}

		// Render scalar field heatmap
		function renderField() {
			const imageData = ctx.createImageData(canvas.width, canvas.height);
			const data = imageData.data;

			// Sample every 2 pixels for better mobile performance
			const step = 2;

			for (let y = 0; y < canvas.height; y += step) {
				for (let x = 0; x < canvas.width; x += step) {
					const value = evaluateField(x, y);
					const normalized = Math.min(1, value / (threshold * 2));

					// Green gradient
					const intensity = normalized * 64;

					// Fill the step x step block
					for (let dy = 0; dy < step && y + dy < canvas.height; dy++) {
						for (let dx = 0; dx < step && x + dx < canvas.width; dx++) {
							const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
							data[idx] = 0;
							data[idx + 1] = intensity;
							data[idx + 2] = 0;
							data[idx + 3] = 180;
						}
					}
				}
			}

			ctx.putImageData(imageData, 0, 0);
		}

		// Render the visualization
		function render() {
			ctx.fillStyle = '#0a0e0a';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			if (!field) {
				computeField();
			}

			// Render scalar field
			if (showField) {
				renderField();
			}

			const cellWidth = canvas.width / gridSize;
			const cellHeight = canvas.height / gridSize;

			// Render filled contours
			if (showFilled) {
				for (let level = levels; level >= 1; level--) {
					const t = threshold * (level / levels) * 1.5;
					const alpha = 0.3 / level;

					ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;

					for (let row = 0; row < gridSize; row++) {
						for (let col = 0; col < gridSize; col++) {
							const v0 = field[row][col];
							const v1 = field[row][col + 1];
							const v2 = field[row + 1][col + 1];
							const v3 = field[row + 1][col];

							const allAbove = v0 > t && v1 > t && v2 > t && v3 > t;
							if (allAbove) {
								const x = col * cellWidth;
								const y = row * cellHeight;
								ctx.fillRect(x, y, cellWidth, cellHeight);
							}
						}
					}
				}
			}

			// Render contour lines
			for (let level = 1; level <= levels; level++) {
				const t = threshold * (level / levels);
				const hue = (level / levels) * 0.3;

				ctx.strokeStyle = `rgba(0, ${Math.floor(200 + 55 * hue)}, 65, 0.9)`;
				ctx.lineWidth = 2;
				ctx.shadowBlur = 8;
				ctx.shadowColor = '#00ff41';

				ctx.beginPath();

				for (let row = 0; row < gridSize; row++) {
					for (let col = 0; col < gridSize; col++) {
						const segments = marchCell(row, col, t, cellWidth, cellHeight);

						for (const [p1, p2] of segments) {
							ctx.moveTo(p1.x, p1.y);
							ctx.lineTo(p2.x, p2.y);
						}
					}
				}

				ctx.stroke();
				ctx.shadowBlur = 0;
			}

			// Render grid
			if (showGrid) {
				ctx.strokeStyle = '#00ff4111';
				ctx.lineWidth = 1;

				for (let i = 0; i <= gridSize; i++) {
					const x = i * cellWidth;
					const y = i * cellHeight;

					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x, canvas.height);
					ctx.stroke();

					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(canvas.width, y);
					ctx.stroke();
				}
			}

			// Render sources
			for (const source of sources) {
				ctx.fillStyle = source.strength > 0 ? '#00ff41' : '#ff4100';
				ctx.shadowBlur = 15;
				ctx.shadowColor = source.strength > 0 ? '#00ff41' : '#ff4100';

				// Larger sources for easier touch on mobile
				const sourceRadius = 8;
				ctx.beginPath();
				ctx.arc(source.x, source.y, sourceRadius, 0, Math.PI * 2);
				ctx.fill();

				ctx.strokeStyle = '#001a00';
				ctx.lineWidth = 2;
				ctx.shadowBlur = 0;
				ctx.stroke();
			}

			updateStats();
		}

		// Update sources (animation)
		function updateSources(delta) {
			for (const source of sources) {
				if (!source.vx) {
					source.vx = (Math.random() - 0.5) * 2;
					source.vy = (Math.random() - 0.5) * 2;
				}

				// Random walk
				source.vx += (Math.random() - 0.5) * 0.3;
				source.vy += (Math.random() - 0.5) * 0.3;

				// Move
				source.x += source.vx;
				source.y += source.vy;

				// Damping
				source.vx *= 0.98;
				source.vy *= 0.98;

				// Boundary bounce
				const margin = 50;
				if (source.x < margin || source.x > canvas.width - margin) {
					source.vx *= -1;
					source.x = Math.max(margin, Math.min(canvas.width - margin, source.x));
				}
				if (source.y < margin || source.y > canvas.height - margin) {
					source.vy *= -1;
					source.y = Math.max(margin, Math.min(canvas.height - margin, source.y));
				}
			}
		}

		// Animation loop
		function animationLoop(timestamp) {
			if (!lastFrameTime) lastFrameTime = timestamp;
			const delta = timestamp - lastFrameTime;

			if (delta >= 1000 / 60) {
				fps = Math.round(1000 / delta);

				if (animate && sources.length > 0) {
					updateSources(delta);
					computeField();
				}

				render();
				lastFrameTime = timestamp;
			}

			requestAnimationFrame(animationLoop);
		}

		// Update stats
		function updateStats() {
			document.getElementById('statSources').textContent = sources.length;
			document.getElementById('statGrid').textContent = `${gridSize}x${gridSize}`;
			document.getElementById('statFps').textContent = fps;
		}

		// Mouse and touch handling
		function getPointerPos(e) {
			const rect = canvas.getBoundingClientRect();
			// Handle both mouse and touch events
			const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
			const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
			return {
				x: clientX - rect.left,
				y: clientY - rect.top
			};
		}

		function findNearestSource(pos, maxDist = 15) {
			let nearest = null;
			let minDist = maxDist;

			for (const source of sources) {
				const dx = pos.x - source.x;
				const dy = pos.y - source.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < minDist) {
					minDist = dist;
					nearest = source;
				}
			}

			return nearest;
		}

		// Unified pointer down handler (mouse + touch)
		function handlePointerDown(e) {
			e.preventDefault();
			const pos = getPointerPos(e);

			if (e.shiftKey) {
				// Remove source
				const source = findNearestSource(pos);
				if (source) {
					sources = sources.filter(s => s !== source);
					computeField();
					render();
				}
			} else {
				// Check if clicking on existing source (for dragging)
				draggedSource = findNearestSource(pos);

				if (!draggedSource) {
					// Add new source
					sources.push({
						x: pos.x,
						y: pos.y,
						strength: strength,
						vx: 0,
						vy: 0
					});
					computeField();
					render();
				}
			}
		}

		// Unified pointer move handler (mouse + touch)
		function handlePointerMove(e) {
			if (draggedSource) {
				e.preventDefault();
				const pos = getPointerPos(e);
				draggedSource.x = pos.x;
				draggedSource.y = pos.y;
				computeField();
				render();
			}
		}

		// Unified pointer up handler (mouse + touch)
		function handlePointerUp(e) {
			draggedSource = null;
		}

		// Mouse events
		canvas.addEventListener('mousedown', handlePointerDown);
		canvas.addEventListener('mousemove', handlePointerMove);
		canvas.addEventListener('mouseup', handlePointerUp);
		canvas.addEventListener('mouseleave', handlePointerUp);

		// Touch events
		canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
		canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
		canvas.addEventListener('touchend', handlePointerUp);
		canvas.addEventListener('touchcancel', handlePointerUp);

		// Controls
		document.getElementById('gridSize').addEventListener('input', (e) => {
			gridSize = parseInt(e.target.value);
			document.getElementById('gridSizeVal').textContent = gridSize;
			computeField();
			render();
		});

		document.getElementById('threshold').addEventListener('input', (e) => {
			threshold = parseFloat(e.target.value);
			document.getElementById('thresholdVal').textContent = threshold.toFixed(1);
			render();
		});

		document.getElementById('strength').addEventListener('input', (e) => {
			strength = parseInt(e.target.value);
			document.getElementById('strengthVal').textContent = strength;
		});

		document.getElementById('levels').addEventListener('input', (e) => {
			levels = parseInt(e.target.value);
			document.getElementById('levelsVal').textContent = levels;
			render();
		});

		document.getElementById('chkAnimate').addEventListener('change', (e) => {
			animate = e.target.checked;
		});

		document.getElementById('chkShowGrid').addEventListener('change', (e) => {
			showGrid = e.target.checked;
			render();
		});

		document.getElementById('chkFilled').addEventListener('change', (e) => {
			showFilled = e.target.checked;
			render();
		});

		document.getElementById('chkField').addEventListener('change', (e) => {
			showField = e.target.checked;
			render();
		});

		document.getElementById('btnClear').addEventListener('click', () => {
			sources = [];
			computeField();
			render();
		});

		// Presets
		document.getElementById('preset').addEventListener('change', (e) => {
			const preset = e.target.value;
			sources = [];

			const margin = 100;
			const w = canvas.width - margin * 2;
			const h = canvas.height - margin * 2;

			switch (preset) {
				case 'metaballs':
					for (let i = 0; i < 8; i++) {
						sources.push({
							x: margin + Math.random() * w,
							y: margin + Math.random() * h,
							strength: 1500 + Math.random() * 1000,
							vx: (Math.random() - 0.5) * 2,
							vy: (Math.random() - 0.5) * 2
						});
					}
					threshold = 1.0;
					levels = 3;
					showFilled = false;
					showField = true;
					animate = true;
					break;

				case 'weather':
					for (let i = 0; i < 12; i++) {
						sources.push({
							x: margin + Math.random() * w,
							y: margin + Math.random() * h,
							strength: 2000 + Math.random() * 2000,
							vx: 0,
							vy: 0
						});
					}
					threshold = 1.2;
					levels = 5;
					showFilled = true;
					showField = false;
					animate = false;
					break;

				case 'terrain':
					for (let i = 0; i < 15; i++) {
						sources.push({
							x: margin + Math.random() * w,
							y: margin + Math.random() * h,
							strength: 1000 + Math.random() * 3000,
							vx: 0,
							vy: 0
						});
					}
					threshold = 0.8;
					levels = 6;
					showFilled = false;
					showField = true;
					animate = false;
					break;

				case 'lava':
					for (let i = 0; i < 6; i++) {
						sources.push({
							x: margin + Math.random() * w,
							y: margin + Math.random() * h,
							strength: 2500 + Math.random() * 1500,
							vx: (Math.random() - 0.5) * 1,
							vy: -1 - Math.random() * 0.5 // Rising
						});
					}
					threshold = 1.0;
					levels = 2;
					showFilled = true;
					showField = true;
					animate = true;
					break;
			}

			// Update UI
			document.getElementById('threshold').value = threshold;
			document.getElementById('thresholdVal').textContent = threshold.toFixed(1);
			document.getElementById('levels').value = levels;
			document.getElementById('levelsVal').textContent = levels;
			document.getElementById('chkFilled').checked = showFilled;
			document.getElementById('chkField').checked = showField;
			document.getElementById('chkAnimate').checked = animate;

			computeField();
			render();
		});

		// Initialize with preset
		document.getElementById('preset').value = 'metaballs';
		document.getElementById('preset').dispatchEvent(new Event('change'));

		// Start animation
		animationLoop(0);
	</script>
</body>
</html>
