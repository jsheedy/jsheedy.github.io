<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Voronoi Diagrams</title>
	<style>
		* { box-sizing: border-box; margin: 0; padding: 0; }
		html, body { height: 100%; overflow: hidden; }
		body {
			font-family: 'Courier New', monospace;
			background: #0a0e0a;
			color: #00ff41;
			display: flex;
			flex-direction: column;
		}

		.title-bar {
			background: linear-gradient(180deg, #1a2a1a 0%, #0f1e0f 100%);
			border-bottom: 3px solid #00ff41;
			padding: 15px 20px;
			text-align: center;
			box-shadow: 0 5px 30px rgba(0, 255, 65, 0.4), inset 0 1px 0 rgba(0, 255, 65, 0.3);
			position: relative;
		}

		.back-link {
			position: absolute;
			left: 20px;
			top: 50%;
			transform: translateY(-50%);
			color: #00ff41;
			text-decoration: none;
			font-family: 'Courier New', monospace;
			font-size: 12px;
			text-transform: uppercase;
			letter-spacing: 1px;
			padding: 8px 15px;
			border: 2px solid #00ff41;
			background: #001a00;
			transition: all 0.2s;
			box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
		}

		.back-link:hover {
			background: #00ff41;
			color: #000;
			box-shadow: 0 0 20px #00ff41;
		}

		.back-link::before {
			content: "← ";
		}

		.title-text {
			font-family: 'Courier New', monospace;
			font-size: 32px;
			font-weight: bold;
			letter-spacing: 8px;
			color: #00ff41;
			text-shadow:
				0 0 10px #00ff41,
				0 0 20px #00ff41,
				0 0 30px #00ff41,
				0 2px 0 #003311;
			margin-bottom: 5px;
			text-transform: uppercase;
		}

		.title-subtitle {
			font-family: 'Courier New', monospace;
			font-size: 11px;
			letter-spacing: 4px;
			color: #00ff4199;
			text-transform: uppercase;
			font-weight: normal;
		}

		.controls {
			background: #001a00;
			border-bottom: 1px solid #00ff4133;
			padding: 12px 20px;
			display: flex;
			flex-wrap: wrap;
			gap: 16px;
			align-items: center;
			font-size: 13px;
		}

		.control-group {
			display: flex;
			align-items: center;
			gap: 8px;
		}

		button {
			background: #001a00;
			color: #00ff41;
			border: 2px solid #00ff41;
			padding: 6px 14px;
			font-family: inherit;
			font-size: 12px;
			cursor: pointer;
			text-transform: uppercase;
			letter-spacing: 1px;
			transition: all 0.15s;
			border-radius: 3px;
		}

		button:hover {
			background: #00ff41;
			color: #001;
			box-shadow: 0 0 15px rgba(0,255,65,0.4);
		}

		button:active {
			transform: scale(0.97);
		}

		label {
			display: flex;
			align-items: center;
			gap: 8px;
			cursor: pointer;
			user-select: none;
		}

		input[type="checkbox"] {
			width: 16px;
			height: 16px;
			cursor: pointer;
		}

		input[type="number"] {
			background: #001a00;
			color: #00ff41;
			border: 2px solid #00ff4133;
			padding: 4px 8px;
			font-family: inherit;
			font-size: 12px;
			width: 60px;
			border-radius: 3px;
		}

		input[type="number"]:focus {
			outline: none;
			border-color: #00ff41;
		}

		.canvas-container {
			flex: 1;
			position: relative;
			overflow: hidden;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
			cursor: crosshair;
		}

		.stats {
			position: absolute;
			top: 12px;
			right: 12px;
			background: rgba(0,26,0,0.85);
			border: 1px solid #00ff4133;
			padding: 10px 14px;
			font-size: 11px;
			line-height: 1.6;
			border-radius: 3px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.5);
		}

		.stats div {
			display: flex;
			justify-content: space-between;
			gap: 12px;
		}

		.stats .label {
			color: #00ff4199;
		}

		.stats .value {
			color: #00ff41;
			font-weight: bold;
		}

		.instructions {
			position: absolute;
			bottom: 12px;
			left: 12px;
			background: rgba(0,26,0,0.85);
			border: 1px solid #00ff4133;
			padding: 10px 14px;
			font-size: 11px;
			line-height: 1.6;
			border-radius: 3px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.5);
		}

		.instructions div {
			color: #00ff4199;
		}

		@keyframes scanline {
			0% { transform: translateY(-100%); }
			100% { transform: translateY(100%); }
		}

		.scanline {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 2px;
			background: linear-gradient(transparent, #00ff4133, transparent);
			pointer-events: none;
			animation: scanline 8s linear infinite;
		}
	</style>
</head>
<body>
	<div class="title-bar">
		<a href="index.html" class="back-link">Experiments</a>
		<div class="title-text">VORONOI DIAGRAMS</div>
		<div class="title-subtitle">Interactive visualization using Delaunay triangulation</div>
	</div>

	<div class="controls">
		<div class="control-group">
			<button id="btnClear">Clear All</button>
			<button id="btnRandom">Random Sites</button>
			<input type="number" id="numRandom" min="3" max="500" value="25" step="1">
		</div>
		<div class="control-group">
			<label><input type="checkbox" id="chkVoronoi" checked> Show Voronoi</label>
			<label><input type="checkbox" id="chkDelaunay"> Show Delaunay</label>
			<label><input type="checkbox" id="chkSites" checked> Show Sites</label>
			<label><input type="checkbox" id="chkDistanceField"> Distance Field</label>
		</div>
	</div>

	<div class="canvas-container">
		<canvas id="canvas"></canvas>
		<div class="scanline"></div>

		<div class="stats">
			<div><span class="label">Sites:</span><span class="value" id="statSites">0</span></div>
			<div><span class="label">Cells:</span><span class="value" id="statCells">0</span></div>
			<div><span class="label">Edges:</span><span class="value" id="statEdges">0</span></div>
		</div>

		<div class="instructions">
			<div>CLICK to add site • DRAG site to move • SHIFT+CLICK to remove</div>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');

		// Sites (Voronoi seed points)
		let sites = [];
		let draggedSite = null;

		// UI state
		let showVoronoi = true;
		let showDelaunay = false;
		let showSites = true;
		let showDistanceField = false;

		// Resize canvas
		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			canvas.width = rect.width;
			canvas.height = rect.height;
			render();
		}
		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		// Delaunay triangulation using Bowyer-Watson algorithm
		class Delaunay {
			constructor(points, width, height) {
				this.points = points;
				this.triangles = [];

				// Create super-triangle that contains all points
				const margin = Math.max(width, height) * 10;
				this.superTriangle = [
					{ x: -margin, y: -margin },
					{ x: width + margin, y: -margin },
					{ x: width / 2, y: height + margin }
				];

				this.triangles.push(this.superTriangle);

				// Add each point
				for (const point of points) {
					this.addPoint(point);
				}

				// Remove triangles that use super-triangle vertices
				this.triangles = this.triangles.filter(tri => {
					return !this.superTriangle.some(sv =>
						tri.some(tv => tv.x === sv.x && tv.y === sv.y)
					);
				});
			}

			addPoint(point) {
				const badTriangles = [];

				// Find all triangles whose circumcircle contains the point
				for (const triangle of this.triangles) {
					if (this.inCircumcircle(point, triangle)) {
						badTriangles.push(triangle);
					}
				}

				// Find the boundary of the polygonal hole
				const polygon = [];
				for (const triangle of badTriangles) {
					for (let i = 0; i < 3; i++) {
						const edge = [triangle[i], triangle[(i + 1) % 3]];
						let isShared = false;

						for (const other of badTriangles) {
							if (other === triangle) continue;
							for (let j = 0; j < 3; j++) {
								const otherEdge = [other[j], other[(j + 1) % 3]];
								if (this.edgesEqual(edge, otherEdge)) {
									isShared = true;
									break;
								}
							}
							if (isShared) break;
						}

						if (!isShared) {
							polygon.push(edge);
						}
					}
				}

				// Remove bad triangles
				this.triangles = this.triangles.filter(tri => !badTriangles.includes(tri));

				// Add new triangles from point to polygon edges
				for (const edge of polygon) {
					this.triangles.push([edge[0], edge[1], point]);
				}
			}

			inCircumcircle(point, triangle) {
				const [a, b, c] = triangle;
				const ax = a.x - point.x;
				const ay = a.y - point.y;
				const bx = b.x - point.x;
				const by = b.y - point.y;
				const cx = c.x - point.x;
				const cy = c.y - point.y;

				const det =
					(ax * ax + ay * ay) * (bx * cy - cx * by) -
					(bx * bx + by * by) * (ax * cy - cx * ay) +
					(cx * cx + cy * cy) * (ax * by - bx * ay);

				return det > 0;
			}

			edgesEqual(edge1, edge2) {
				return (edge1[0] === edge2[0] && edge1[1] === edge2[1]) ||
				       (edge1[0] === edge2[1] && edge1[1] === edge2[0]);
			}

			getCircumcenter(triangle) {
				const [a, b, c] = triangle;
				const d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));

				if (Math.abs(d) < 0.0001) return null;

				const ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) +
				           (b.x * b.x + b.y * b.y) * (c.y - a.y) +
				           (c.x * c.x + c.y * c.y) * (a.y - b.y)) / d;
				const uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) +
				           (b.x * b.x + b.y * b.y) * (a.x - c.x) +
				           (c.x * c.x + c.y * c.y) * (b.x - a.x)) / d;

				return { x: ux, y: uy };
			}
		}

		// Compute Voronoi cells from Delaunay triangulation
		function computeVoronoi(delaunay) {
			const voronoiEdges = [];
			const cellMap = new Map(); // site -> cell vertices

			// Build adjacency map for triangles
			const triangleMap = new Map();
			for (let i = 0; i < delaunay.triangles.length; i++) {
				const tri = delaunay.triangles[i];
				for (const vertex of tri) {
					if (!triangleMap.has(vertex)) {
						triangleMap.set(vertex, []);
					}
					triangleMap.get(vertex).push(i);
				}
			}

			// For each site, find all triangles that contain it and connect circumcenters
			for (const site of sites) {
				const triangleIndices = triangleMap.get(site) || [];
				const circumcenters = [];

				for (const idx of triangleIndices) {
					const center = delaunay.getCircumcenter(delaunay.triangles[idx]);
					if (center) {
						circumcenters.push(center);
					}
				}

				if (circumcenters.length > 0) {
					// Sort circumcenters by angle around site
					circumcenters.sort((a, b) => {
						const angleA = Math.atan2(a.y - site.y, a.x - site.x);
						const angleB = Math.atan2(b.y - site.y, b.x - site.x);
						return angleA - angleB;
					});

					cellMap.set(site, circumcenters);
				}
			}

			// Create edges between adjacent circumcenters
			for (let i = 0; i < delaunay.triangles.length; i++) {
				const tri = delaunay.triangles[i];
				const center = delaunay.getCircumcenter(tri);
				if (!center) continue;

				// Find adjacent triangles
				for (let j = i + 1; j < delaunay.triangles.length; j++) {
					const other = delaunay.triangles[j];
					const otherCenter = delaunay.getCircumcenter(other);
					if (!otherCenter) continue;

					// Check if triangles share an edge
					let sharedVertices = 0;
					for (const v1 of tri) {
						for (const v2 of other) {
							if (v1 === v2) sharedVertices++;
						}
					}

					if (sharedVertices === 2) {
						voronoiEdges.push([center, otherCenter]);
					}
				}
			}

			return { edges: voronoiEdges, cells: cellMap };
		}

		// Render the visualization
		function render() {
			ctx.fillStyle = '#0a0e0a';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			if (sites.length === 0) {
				updateStats(0, 0, 0);
				return;
			}

			// Compute Delaunay triangulation
			const delaunay = new Delaunay(sites, canvas.width, canvas.height);
			const voronoi = computeVoronoi(delaunay);

			// Distance field visualization
			if (showDistanceField) {
				renderDistanceField();
			}

			// Draw Voronoi edges
			if (showVoronoi) {
				ctx.strokeStyle = '#00ff41';
				ctx.lineWidth = 1.5;
				ctx.shadowBlur = 8;
				ctx.shadowColor = '#00ff41';

				for (const [p1, p2] of voronoi.edges) {
					ctx.beginPath();
					ctx.moveTo(p1.x, p1.y);
					ctx.lineTo(p2.x, p2.y);
					ctx.stroke();
				}

				ctx.shadowBlur = 0;
			}

			// Draw Delaunay triangulation
			if (showDelaunay) {
				ctx.strokeStyle = '#00ff4166';
				ctx.lineWidth = 1;

				for (const triangle of delaunay.triangles) {
					ctx.beginPath();
					ctx.moveTo(triangle[0].x, triangle[0].y);
					ctx.lineTo(triangle[1].x, triangle[1].y);
					ctx.lineTo(triangle[2].x, triangle[2].y);
					ctx.closePath();
					ctx.stroke();
				}
			}

			// Draw sites
			if (showSites) {
				for (const site of sites) {
					ctx.fillStyle = '#00ff41';
					ctx.shadowBlur = 10;
					ctx.shadowColor = '#00ff41';
					ctx.beginPath();
					ctx.arc(site.x, site.y, 4, 0, Math.PI * 2);
					ctx.fill();

					ctx.strokeStyle = '#001a00';
					ctx.lineWidth = 2;
					ctx.shadowBlur = 0;
					ctx.stroke();
				}
			}

			updateStats(sites.length, voronoi.cells.size, voronoi.edges.length);
		}

		// Render distance field (color-coded proximity heatmap)
		function renderDistanceField() {
			const imageData = ctx.createImageData(canvas.width, canvas.height);
			const data = imageData.data;

			// Sample every 2 pixels for performance
			const step = 2;

			for (let y = 0; y < canvas.height; y += step) {
				for (let x = 0; x < canvas.width; x += step) {
					let minDist = Infinity;
					let nearestSite = null;

					// Find nearest site
					for (const site of sites) {
						const dx = x - site.x;
						const dy = y - site.y;
						const dist = Math.sqrt(dx * dx + dy * dy);
						if (dist < minDist) {
							minDist = dist;
							nearestSite = site;
						}
					}

					if (nearestSite) {
						// Color based on distance (darker = closer)
						const intensity = Math.max(0, Math.min(1, minDist / 150));
						const r = 0;
						const g = Math.floor(intensity * 64);
						const b = 0;

						// Fill the step x step block
						for (let dy = 0; dy < step && y + dy < canvas.height; dy++) {
							for (let dx = 0; dx < step && x + dx < canvas.width; dx++) {
								const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
								data[idx] = r;
								data[idx + 1] = g;
								data[idx + 2] = b;
								data[idx + 3] = 180;
							}
						}
					}
				}
			}

			ctx.putImageData(imageData, 0, 0);
		}

		// Update statistics
		function updateStats(numSites, numCells, numEdges) {
			document.getElementById('statSites').textContent = numSites;
			document.getElementById('statCells').textContent = numCells;
			document.getElementById('statEdges').textContent = numEdges;
		}

		// Mouse handling
		function getMousePos(e) {
			const rect = canvas.getBoundingClientRect();
			return {
				x: e.clientX - rect.left,
				y: e.clientY - rect.top
			};
		}

		function findNearestSite(pos, maxDist = 15) {
			let nearest = null;
			let minDist = maxDist;

			for (const site of sites) {
				const dx = pos.x - site.x;
				const dy = pos.y - site.y;
				const dist = Math.sqrt(dx * dx + dy * dy);
				if (dist < minDist) {
					minDist = dist;
					nearest = site;
				}
			}

			return nearest;
		}

		canvas.addEventListener('mousedown', (e) => {
			const pos = getMousePos(e);

			if (e.shiftKey) {
				// Remove site
				const site = findNearestSite(pos);
				if (site) {
					sites = sites.filter(s => s !== site);
					render();
				}
			} else {
				// Check if clicking on existing site (for dragging)
				draggedSite = findNearestSite(pos);

				if (!draggedSite) {
					// Add new site
					sites.push({ x: pos.x, y: pos.y });
					render();
				}
			}
		});

		canvas.addEventListener('mousemove', (e) => {
			if (draggedSite) {
				const pos = getMousePos(e);
				draggedSite.x = pos.x;
				draggedSite.y = pos.y;
				render();
			}
		});

		canvas.addEventListener('mouseup', () => {
			draggedSite = null;
		});

		canvas.addEventListener('mouseleave', () => {
			draggedSite = null;
		});

		// Controls
		document.getElementById('btnClear').addEventListener('click', () => {
			sites = [];
			render();
		});

		document.getElementById('btnRandom').addEventListener('click', () => {
			const n = parseInt(document.getElementById('numRandom').value);
			sites = [];

			const margin = 50;
			for (let i = 0; i < n; i++) {
				sites.push({
					x: margin + Math.random() * (canvas.width - margin * 2),
					y: margin + Math.random() * (canvas.height - margin * 2)
				});
			}

			render();
		});

		document.getElementById('chkVoronoi').addEventListener('change', (e) => {
			showVoronoi = e.target.checked;
			render();
		});

		document.getElementById('chkDelaunay').addEventListener('change', (e) => {
			showDelaunay = e.target.checked;
			render();
		});

		document.getElementById('chkSites').addEventListener('change', (e) => {
			showSites = e.target.checked;
			render();
		});

		document.getElementById('chkDistanceField').addEventListener('change', (e) => {
			showDistanceField = e.target.checked;
			render();
		});

		// Initialize with some random sites
		document.getElementById('btnRandom').click();
	</script>
</body>
</html>
