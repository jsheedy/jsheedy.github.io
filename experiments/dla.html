<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion Limited Aggregation - Brownian Tree</title>
    <link rel="stylesheet" href="styles/terminal-theme.css">
    <style>
        /* Experiment-specific styles */

        #main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #info-sidebar {
            width: 320px;
            padding: 20px;
            background: rgba(0, 255, 65, 0.05);
            border-right: 2px solid #00ff41;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        #info-sidebar h3 {
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.8);
        }

        #info-sidebar p {
            font-size: 11px;
            line-height: 1.6;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        #info-sidebar ul {
            font-size: 11px;
            line-height: 1.8;
            margin-left: 15px;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        #info-sidebar .section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
        }

        #info-sidebar .section:last-child {
            border-bottom: none;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #zoom-indicator {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 65, 0.6);
            color: #00ff41;
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 6px rgba(0, 255, 65, 0.6);
            pointer-events: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #controls {
            width: 320px;
            padding: 20px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 2px solid #00ff41;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
        }

        .control-group:last-child {
            border-bottom: none;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        select, button {
            width: 100%;
            padding: 8px;
            background: rgba(0, 255, 65, 0.1);
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        select:hover, button:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        select option {
            background: rgba(0, 20, 0, 0.95);
            color: #00ff41;
            padding: 8px;
        }

        button {
            margin-bottom: 8px;
        }

        .value-display {
            display: inline-block;
            float: right;
        }

        #stats {
            font-size: 11px;
            line-height: 1.6;
        }

        #stats div {
            margin-bottom: 4px;
        }

        .stat-label {
            display: inline-block;
            width: 140px;
        }

        .stat-value {
            float: right;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.8);
        }

        /* Experiment-specific scanline effect on canvas */
        #canvas-container::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <a href="index.html" class="back-link">Experiments</a>
        <div class="title-text">DIFFUSION LIMITED AGGREGATION</div>
        <div class="title-subtitle">Brownian Tree Growth Simulation</div>
    </div>

    <div id="main">
        <div id="info-sidebar">
            <div class="section">
                <h3>[ WHAT IS DLA? ]</h3>
                <p>Diffusion Limited Aggregation is a process where particles undergoing random walks stick together to form branching, fractal-like structures called Brownian trees.</p>
                <p>DLA was first simulated by Witten and Sander in 1981 and appears in many natural phenomena.</p>
            </div>

            <div class="section">
                <h3>[ HOW IT WORKS ]</h3>
                <p>1. Start with a seed particle at the center</p>
                <p>2. Release particles that perform random walks</p>
                <p>3. When a walker touches the structure, it sticks</p>
                <p>4. Repeat to grow the tree</p>
            </div>

            <div class="section">
                <h3>[ NATURAL EXAMPLES ]</h3>
                <ul>
                    <li>Electrodeposition</li>
                    <li>Coral growth</li>
                    <li>Mineral dendrites</li>
                    <li>Lightning patterns</li>
                    <li>Blood vessel formation</li>
                    <li>Snowflake formation</li>
                    <li>Bacterial colonies</li>
                </ul>
            </div>

            <div class="section">
                <h3>[ PROPERTIES ]</h3>
                <p>DLA structures are fractals with a dimension typically around 1.7 in 2D. They exhibit self-similarity at different scales and have a characteristic branching pattern.</p>
                <p>The structures are highly sensitive to initial conditions and stochastic in nature.</p>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="zoom-indicator">Zoom: 100%</div>
        </div>

        <div id="controls">
            <div class="control-group">
                <button id="playPauseBtn">PAUSE</button>
                <button id="resetBtn">RESET</button>
            </div>

            <div class="control-group">
                <label>
                    Simulation Speed
                    <span class="value-display" id="speedValue">5.0x</span>
                </label>
                <input type="range" id="speed" min="1" max="200" value="50">
            </div>

            <div class="control-group">
                <label>
                    Steps Multiplier
                    <span class="value-display" id="particlesPerFrameValue">1.0x</span>
                </label>
                <input type="range" id="particlesPerFrame" min="1" max="30" value="10">
            </div>

            <div class="control-group">
                <label>
                    Stick Probability
                    <span class="value-display" id="stickProbValue">1.00</span>
                </label>
                <input type="range" id="stickProb" min="10" max="100" value="100">
            </div>

            <div class="control-group">
                <label>
                    Simultaneous Walkers
                    <span class="value-display" id="walkerCountValue">200</span>
                </label>
                <input type="range" id="walkerCount" min="1" max="500" value="200">
            </div>

            <div class="control-group">
                <label>
                    Spawn Radius Multiplier
                    <span class="value-display" id="spawnRadiusValue">0.9</span>
                </label>
                <input type="range" id="spawnRadius" min="0" max="200" value="90">
            </div>

            <div class="control-group">
                <label>
                    Kill Radius Multiplier
                    <span class="value-display" id="killRadiusValue">1.2</span>
                </label>
                <input type="range" id="killRadius" min="0" max="500" value="120">
            </div>

            <div class="control-group">
                <label>
                    Max Radius
                    <span class="value-display" id="maxRadiusLimitValue">500</span>
                </label>
                <input type="range" id="maxRadiusLimit" min="50" max="1500" value="500">
            </div>

            <div class="control-group">
                <label>Seed Pattern</label>
                <select id="seedPattern">
                    <option value="center">Center Point</option>
                    <option value="hline">Horizontal Line</option>
                    <option value="vline">Vertical Line</option>
                    <option value="circle">Circle Outline</option>
                    <option value="multi">Multiple Points</option>
                </select>
            </div>

            <div class="control-group">
                <label>Color Scheme</label>
                <select id="colorScheme">
                    <option value="distance">Distance from Center</option>
                    <option value="age">Age (Time)</option>
                    <option value="green">Monochrome Green</option>
                    <option value="rainbow">Rainbow</option>
                </select>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showWalkers" style="width: auto; margin-right: 5px;" checked="checked">
                    Show Active Walkers
                </label>
            </div>

            <div class="control-group">
                <h3 style="margin-bottom: 10px; font-size: 14px;">[ STATISTICS ]</h3>
                <div id="stats">
                    <div><span class="stat-label">Particles Stuck:</span><span class="stat-value" id="particleCount">0</span></div>
                    <div><span class="stat-label">Active Walkers:</span><span class="stat-value" id="activeWalkers">0</span></div>
                    <div><span class="stat-label">Current Spawn R:</span><span class="stat-value" id="currentSpawnRadius">0</span></div>
                    <div><span class="stat-label">Particles/Sec:</span><span class="stat-value" id="particlesPerSec">0</span></div>
                    <div><span class="stat-label">Bounding Radius:</span><span class="stat-value" id="boundingRadius">0</span></div>
                    <div><span class="stat-label">Zoom Level:</span><span class="stat-value" id="zoomLevel">100%</span></div>
                    <div><span class="stat-label">FPS:</span><span class="stat-value" id="fps">0</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to fill container
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Camera/viewport system
        let camera = {
            x: 0,           // Center of view in simulation space
            y: 0,
            zoom: 10,       // Start very zoomed in (pixels per simulation unit)
            targetZoom: 10,
            minZoom: 0.5,   // Maximum zoom out
            maxZoom: 20     // Maximum zoom in
        };

        // Simulation state - now in simulation space with (0,0) at center
        let particles = [];
        let walkers = [];
        let grid = new Map(); // Spatial hash grid
        let maxRadius = 0;
        let isPaused = false;
        let frameCount = 0;
        let lastTime = Date.now();
        let particlesAddedLastSec = 0;
        let lastSecTime = Date.now();
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        // Settings
        let settings = {
            speed: 5.0,
            particlesPerFrame: 1.0,  // Now used as steps multiplier
            stickProbability: 1.0,
            walkerCount: 200,
            spawnRadiusMult: 0.9,
            killRadiusMult: 1.2,
            maxRadiusLimit: 500,
            seedPattern: 'center',
            colorScheme: 'distance',
            showWalkers: true
        };

        // Grid cell size for spatial hashing (in simulation units)
        const CELL_SIZE = 4;

        // Helper functions
        function hashKey(x, y) {
            const gx = Math.floor(x / CELL_SIZE);
            const gy = Math.floor(y / CELL_SIZE);
            return `${gx},${gy}`;
        }

        function addToGrid(particle) {
            const key = hashKey(particle.x, particle.y);
            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push(particle);
        }

        function isNearStructure(x, y) {
            const gx = Math.floor(x / CELL_SIZE);
            const gy = Math.floor(y / CELL_SIZE);

            // Check neighboring cells
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${gx + dx},${gy + dy}`;
                    const cell = grid.get(key);
                    if (cell && cell.length > 0) {
                        // Check actual distance to particles in cell
                        // Use squared distance to avoid expensive sqrt
                        for (const p of cell) {
                            const dx = x - p.x;
                            const dy = y - p.y;
                            const distSquared = dx * dx + dy * dy;
                            if (distSquared < 4) { // dist < 2, so dist^2 < 4
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function initializeSeeds() {
            particles = [];
            grid.clear();
            maxRadius = 0;

            // Simulation space is centered at (0, 0)
            switch (settings.seedPattern) {
                case 'center':
                    addParticle(0, 0, 0);
                    break;

                case 'hline':
                    for (let i = -20; i <= 20; i += 2) {
                        addParticle(i, 0, 0);
                    }
                    break;

                case 'vline':
                    for (let i = -20; i <= 20; i += 2) {
                        addParticle(0, i, 0);
                    }
                    break;

                case 'circle':
                    const circleRadius = 30;
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                        const x = Math.cos(angle) * circleRadius;
                        const y = Math.sin(angle) * circleRadius;
                        addParticle(x, y, 0);
                    }
                    break;

                case 'multi':
                    const positions = [
                        [-40, 0],
                        [40, 0],
                        [0, -40],
                        [0, 40]
                    ];
                    for (const [x, y] of positions) {
                        addParticle(x, y, 0);
                    }
                    break;
            }
        }

        function addParticle(x, y, age) {
            const particle = {
                x,
                y,
                age,
                color: null // Will be calculated lazily
            };
            particles.push(particle);
            addToGrid(particle);

            const distSquared = x * x + y * y;
            const dist = Math.sqrt(distSquared);
            maxRadius = Math.max(maxRadius, dist);
        }

        class Walker {
            constructor() {
                this.respawn();
            }

            respawn() {
                const spawnRadius = (maxRadius + 10) * settings.spawnRadiusMult;
                const angle = Math.random() * Math.PI * 2;
                this.x = Math.cos(angle) * spawnRadius;
                this.y = Math.sin(angle) * spawnRadius;
            }

            walk() {
                // Random walk in 4 directions
                const dir = Math.floor(Math.random() * 4);
                switch (dir) {
                    case 0: this.x += 1; break;
                    case 1: this.x -= 1; break;
                    case 2: this.y += 1; break;
                    case 3: this.y -= 1; break;
                }
            }

            update() {
                this.walk();

                // Check if stuck to structure
                if (isNearStructure(this.x, this.y)) {
                    if (Math.random() < settings.stickProbability) {
                        const distSquared = this.x * this.x + this.y * this.y;
                        const limitSquared = settings.maxRadiusLimit * settings.maxRadiusLimit;
                        if (distSquared > limitSquared) {
                            this.respawn();
                            return false;
                        }
                        addParticle(this.x, this.y, frameCount);
                        particlesAddedLastSec++;
                        this.respawn();
                        return true;
                    }
                }

                // Check if too far away (use squared distance)
                const distSquared = this.x * this.x + this.y * this.y;
                const killRadius = (maxRadius + 10) * settings.killRadiusMult;
                const killRadiusSquared = killRadius * killRadius;
                if (distSquared > killRadiusSquared) {
                    this.respawn();
                }

                return false;
            }
        }

        function getParticleColor(particle) {
            // Return cached color if available and color scheme is cacheable
            if (particle.color && settings.colorScheme !== 'age') {
                return particle.color;
            }

            let color;
            const distSquared = particle.x * particle.x + particle.y * particle.y;

            switch (settings.colorScheme) {
                case 'distance':
                    const dist = Math.sqrt(distSquared);
                    const hue = (dist / maxRadius) * 120;
                    color = `hsl(${120 - hue}, 100%, 50%)`;
                    break;

                case 'age':
                    // Age color changes over time, don't cache
                    const age = frameCount - particle.age;
                    const ageHue = (age / frameCount) * 120;
                    return `hsl(${120 - ageHue}, 100%, 50%)`;

                case 'green':
                    color = '#00ff41';
                    break;

                case 'rainbow':
                    const rainbowDist = Math.sqrt(distSquared);
                    const rainbowHue = (rainbowDist / maxRadius) * 360;
                    color = `hsl(${rainbowHue}, 100%, 50%)`;
                    break;
            }

            // Cache the color
            particle.color = color;
            return color;
        }

        function invalidateColorCache() {
            for (const particle of particles) {
                particle.color = null;
            }
        }

        // Transform simulation coordinates to screen coordinates
        function simToScreen(simX, simY) {
            const screenX = (simX - camera.x) * camera.zoom + canvas.width / 2;
            const screenY = (simY - camera.y) * camera.zoom + canvas.height / 2;
            return { x: screenX, y: screenY };
        }

        function screenToSim(screenX, screenY, zoom = camera.zoom) {
            const simX = (screenX - canvas.width / 2) / zoom + camera.x;
            const simY = (screenY - canvas.height / 2) / zoom + camera.y;
            return { x: simX, y: simY };
        }

        function updateCamera() {
            // Smoothly interpolate zoom
            camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;

            // Auto-adjust zoom to keep structure in view
            if (maxRadius > 0) {
                // Calculate zoom needed to fit structure with some padding
                const padding = 1.5; // 50% padding
                const structureSize = maxRadius * 2 * padding;
                const canvasSize = Math.min(canvas.width, canvas.height);
                const neededZoom = canvasSize / structureSize;

                // Gradually zoom out as structure grows
                if (neededZoom < camera.targetZoom) {
                    camera.targetZoom = Math.max(neededZoom, camera.minZoom);
                }
            }
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update camera
            updateCamera();

            // Draw spawn/kill radius rings
            const center = simToScreen(0, 0);
            const spawnRadius = (maxRadius + 0) * settings.spawnRadiusMult;
            const killRadius = (maxRadius + 0) * settings.killRadiusMult;
            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 255, 65, 0.35)';
            ctx.beginPath();
            ctx.arc(center.x, center.y, spawnRadius * camera.zoom, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = 'rgba(255, 80, 80, 0.35)';
            ctx.beginPath();
            ctx.arc(center.x, center.y, killRadius * camera.zoom, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Calculate viewport bounds in simulation space for culling
            const viewportMargin = 10; // Small margin to avoid edge artifacts
            const minX = camera.x - (canvas.width / 2 / camera.zoom) - viewportMargin;
            const maxX = camera.x + (canvas.width / 2 / camera.zoom) + viewportMargin;
            const minY = camera.y - (canvas.height / 2 / camera.zoom) - viewportMargin;
            const maxY = camera.y + (canvas.height / 2 / camera.zoom) + viewportMargin;

            // Calculate particle size based on zoom (min 1px, max 4px)
            const particleSize = Math.max(3, Math.min(4, camera.zoom * 0.5));

            // Draw particles with viewport culling
            for (const particle of particles) {
                // Cull particles outside viewport
                if (particle.x < minX || particle.x > maxX ||
                    particle.y < minY || particle.y > maxY) {
                    continue;
                }

                const screen = simToScreen(particle.x, particle.y);
                ctx.fillStyle = getParticleColor(particle);
                ctx.fillRect(screen.x - particleSize/2, screen.y - particleSize/2, particleSize, particleSize);
            }

            // Draw walkers if enabled
            if (settings.showWalkers) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                const walkerSize = Math.max(1, Math.min(3, camera.zoom * 0.4));
                for (const walker of walkers) {
                    // Cull walkers outside viewport
                    if (walker.x < minX || walker.x > maxX ||
                        walker.y < minY || walker.y > maxY) {
                        continue;
                    }
                    const screen = simToScreen(walker.x, walker.y);
                    ctx.fillRect(screen.x - walkerSize/2, screen.y - walkerSize/2, walkerSize, walkerSize);
                }
            }
        }

        function update() {
            if (isPaused) return;

            // Update each walker once per simulation step
            for (const walker of walkers) {
                walker.update();
            }

            frameCount++;
        }

        function animate() {
            // Run simulation steps based on speed and multiplier
            // Each step updates all walkers once
            const stepsPerFrame = Math.ceil(settings.speed * settings.particlesPerFrame);
            for (let i = 0; i < stepsPerFrame; i++) {
                update();
            }
            render();

            // Update FPS
            const now = Date.now();
            const delta = now - lastTime;
            if (delta > 100) {
                const fps = Math.round(1000 / delta);
                document.getElementById('fps').textContent = fps;
                lastTime = now;
            }

            // Update particles per second
            if (now - lastSecTime > 1000) {
                document.getElementById('particlesPerSec').textContent = particlesAddedLastSec;
                particlesAddedLastSec = 0;
                lastSecTime = now;
            }

            // Update stats
            document.getElementById('particleCount').textContent = particles.length;
            document.getElementById('activeWalkers').textContent = walkers.length;
            document.getElementById('currentSpawnRadius').textContent = Math.round((maxRadius + 10) * settings.spawnRadiusMult);
            document.getElementById('boundingRadius').textContent = Math.round(maxRadius);
            document.getElementById('zoomLevel').textContent = Math.round(camera.zoom * 10) + '%';
            document.getElementById('zoom-indicator').textContent = 'Zoom: ' + Math.round(camera.zoom * 10) + '%';

            requestAnimationFrame(animate);
        }

        // Control handlers
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('playPauseBtn').textContent = isPaused ? 'PLAY' : 'PAUSE';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initializeSeeds();
            walkers = [];
            for (let i = 0; i < settings.walkerCount; i++) {
                walkers.push(new Walker());
            }
            frameCount = 0;
            particlesAddedLastSec = 0;
            camera.zoom = 10;
            camera.targetZoom = 10;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            settings.speed = parseInt(e.target.value) / 10;
            document.getElementById('speedValue').textContent = settings.speed.toFixed(1) + 'x';
        });

        document.getElementById('particlesPerFrame').addEventListener('input', (e) => {
            settings.particlesPerFrame = parseInt(e.target.value) / 10;
            document.getElementById('particlesPerFrameValue').textContent = settings.particlesPerFrame.toFixed(1) + 'x';
        });

        document.getElementById('stickProb').addEventListener('input', (e) => {
            settings.stickProbability = parseInt(e.target.value) / 100;
            document.getElementById('stickProbValue').textContent = settings.stickProbability.toFixed(2);
        });

        document.getElementById('walkerCount').addEventListener('input', (e) => {
            const newCount = parseInt(e.target.value);
            document.getElementById('walkerCountValue').textContent = newCount;

            while (walkers.length < newCount) {
                walkers.push(new Walker());
            }
            while (walkers.length > newCount) {
                walkers.pop();
            }
            settings.walkerCount = newCount;
        });

        document.getElementById('spawnRadius').addEventListener('input', (e) => {
            settings.spawnRadiusMult = parseInt(e.target.value) / 100;
            document.getElementById('spawnRadiusValue').textContent = settings.spawnRadiusMult.toFixed(1);
        });

        document.getElementById('killRadius').addEventListener('input', (e) => {
            settings.killRadiusMult = parseInt(e.target.value) / 100;
            document.getElementById('killRadiusValue').textContent = settings.killRadiusMult.toFixed(1);
        });

        document.getElementById('maxRadiusLimit').addEventListener('input', (e) => {
            settings.maxRadiusLimit = parseInt(e.target.value);
            document.getElementById('maxRadiusLimitValue').textContent = settings.maxRadiusLimit;
        });

        document.getElementById('seedPattern').addEventListener('change', (e) => {
            settings.seedPattern = e.target.value;
        });

        document.getElementById('colorScheme').addEventListener('change', (e) => {
            settings.colorScheme = e.target.value;
            invalidateColorCache();
        });

        document.getElementById('showWalkers').addEventListener('change', (e) => {
            settings.showWalkers = e.target.checked;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const before = screenToSim(screenX, screenY);

            const zoomFactor = Math.exp(-e.deltaY * 0.0015);
            const nextZoom = Math.min(camera.maxZoom, Math.max(camera.minZoom, camera.targetZoom * zoomFactor));

            camera.targetZoom = nextZoom;
            camera.x = before.x - (screenX - canvas.width / 2) / nextZoom;
            camera.y = before.y - (screenY - canvas.height / 2) / nextZoom;
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) {
                return;
            }
            isPanning = true;
            lastPanX = e.clientX;
            lastPanY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (e) => {
            if (!isPanning) {
                return;
            }
            const dx = e.clientX - lastPanX;
            const dy = e.clientY - lastPanY;
            lastPanX = e.clientX;
            lastPanY = e.clientY;
            camera.x -= dx / camera.zoom;
            camera.y -= dy / camera.zoom;
        });

        window.addEventListener('mouseup', () => {
            if (!isPanning) {
                return;
            }
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        });

        // Initialize
        initializeSeeds();
        for (let i = 0; i < settings.walkerCount; i++) {
            walkers.push(new Walker());
        }

        // Start animation
        animate();
    </script>
</body>
</html>
