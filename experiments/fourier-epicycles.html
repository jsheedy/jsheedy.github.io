<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fourier Epicycles Drawing Machine</title>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Courier New', monospace;
  background: #0a0e0a;
  color: #00ff41;
  overflow: hidden;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.title-bar {
  background: linear-gradient(180deg, #1a2a1a 0%, #0f1e0f 100%);
  border-bottom: 3px solid #00ff41;
  padding: 15px 20px;
  text-align: center;
  box-shadow: 0 5px 30px rgba(0, 255, 65, 0.4), inset 0 1px 0 rgba(0, 255, 65, 0.3);
  position: relative;
}

.back-link {
  position: absolute;
  left: 20px;
  top: 50%;
  transform: translateY(-50%);
  color: #00ff41;
  text-decoration: none;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 8px 15px;
  border: 2px solid #00ff41;
  background: #001a00;
  transition: all 0.2s;
  box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
}

.back-link:hover {
  background: #00ff41;
  color: #000;
  box-shadow: 0 0 20px #00ff41;
}

.back-link::before {
  content: "<- ";
}

.title-text {
  font-family: 'Courier New', monospace;
  font-size: 28px;
  font-weight: bold;
  letter-spacing: 6px;
  color: #00ff41;
  text-shadow:
    0 0 10px #00ff41,
    0 0 20px #00ff41,
    0 0 30px #00ff41,
    0 2px 0 #003311;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.title-subtitle {
  font-family: 'Courier New', monospace;
  font-size: 11px;
  letter-spacing: 4px;
  color: #00ff4199;
  text-transform: uppercase;
  font-weight: normal;
}

#canvas {
  display: block;
  background: #000;
  flex: 1;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  box-shadow: inset 0 0 100px rgba(0, 255, 65, 0.05);
}

.main-area {
  display: flex;
  flex: 1;
  min-height: 0;
}

.sidebar {
  width: 280px;
  border-left: 2px solid #00ff41;
  background: linear-gradient(180deg, #0f1e0f 0%, #071207 100%);
  padding: 16px 14px;
  box-shadow: inset 0 0 30px rgba(0, 255, 65, 0.15);
}

.sidebar h2 {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 10px;
  text-shadow: 0 0 8px #00ff41;
}

.sidebar p {
  font-size: 11px;
  line-height: 1.4;
  color: #00ff41cc;
  margin-bottom: 10px;
}

.sidebar .callout {
  border: 1px solid #00ff4160;
  padding: 10px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #00ff4199;
  background: #001a00;
}

.control-panel {
  background: linear-gradient(180deg, #0f1e0f 0%, #071207 100%);
  border-top: 2px solid #00ff41;
  padding: 12px 18px 14px;
  box-shadow: 0 -5px 30px rgba(0, 255, 65, 0.3);
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #00ff41;
  text-shadow: 0 0 5px #00ff41;
  font-weight: bold;
}

.value-display {
  color: #0f0;
  font-size: 13px;
  text-shadow: 0 0 8px #00ff41;
}

input[type="range"] {
  width: 100%;
  height: 4px;
  background: #001a00;
  border: 1px solid #00ff41;
  outline: none;
  -webkit-appearance: none;
  box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background: #00ff41;
  cursor: pointer;
  border-radius: 50%;
  box-shadow: 0 0 10px #00ff41;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #00ff41;
  cursor: pointer;
  border-radius: 50%;
  border: none;
  box-shadow: 0 0 10px #00ff41;
}

select,
input[type="text"] {
  width: 100%;
  background: #001a00;
  color: #00ff41;
  border: 2px solid #00ff41;
  padding: 8px;
  font-family: 'Courier New', monospace;
  font-size: 12px;
}

input[type="text"]::placeholder {
  color: #00ff4170;
}

button {
  background: #001a00;
  color: #00ff41;
  border: 2px solid #00ff41;
  padding: 10px 20px;
  cursor: pointer;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
  transition: all 0.2s;
  box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
}

button:hover {
  background: #00ff41;
  color: #000;
  box-shadow: 0 0 20px #00ff41;
}

button:active {
  transform: scale(0.95);
}

.stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 10px;
  margin-bottom: 6px;
  padding-bottom: 6px;
  border-bottom: 1px solid #00ff4140;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 18px;
  font-weight: bold;
  color: #0f0;
  text-shadow: 0 0 10px #00ff41;
  font-family: 'Courier New', monospace;
}

.stat-label {
  font-size: 9px;
  color: #00ff4199;
  margin-top: 2px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.button-group {
  display: flex;
  gap: 10px;
  grid-column: span 2;
}

.button-group button {
  flex: 1;
}

input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #00ff41;
  filter: brightness(1.2);
}

canvas#spectrum {
  width: 100%;
  height: 100px;
  background: #001a00;
  border: 1px solid #00ff41;
  box-shadow: inset 0 0 20px rgba(0, 255, 65, 0.2);
}

body::before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    rgba(0, 255, 65, 0.03) 0px,
    transparent 1px,
    transparent 2px,
    rgba(0, 255, 65, 0.03) 3px
  );
  pointer-events: none;
  z-index: 1000;
}

@keyframes flicker {
  0% { opacity: 0.98; }
  50% { opacity: 1; }
  100% { opacity: 0.98; }
}

#canvas {
  animation: flicker 0.15s infinite;
}

.tip {
  color: #00ff4199;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-top: 6px;
}

@media (max-width: 900px) {
  .main-area {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    border-left: none;
    border-top: 2px solid #00ff41;
    box-shadow: inset 0 0 20px rgba(0, 255, 65, 0.12);
  }
}
</style>
</head>
<body>
  <div class="title-bar">
    <a href="index.html" class="back-link">Experiments</a>
    <div class="title-text">FOURIER EPICYCLES</div>
    <div class="title-subtitle">ROTATING VECTORS DRAWING MACHINE</div>
  </div>

  <div class="main-area">
    <canvas id="canvas"></canvas>
    <aside class="sidebar">
      <h2>Fourier Epicycles</h2>
      <p>Any closed path can be rebuilt by spinning vectors. Each vector is a Fourier coefficient with a frequency, radius, and phase.</p>
      <p>Stack the circles tip-to-tail and the final point draws the original shape as time advances through one cycle.</p>
      <p>The Discrete Fourier Transform converts the sampled path into complex coefficients: f(t) = x(t) + i·y(t), cₙ = Σ f(t)e^(-2πint/N).</p>
      <p>Each cₙ becomes an epicycle with radius |cₙ| and angular velocity n. Summing them reconstructs the path.</p>
      <div class="callout">Lower frequencies capture the big shape. Higher frequencies add detail.</div>
    </aside>
  </div>

  <div class="control-panel">
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="statFps">0</div>
        <div class="stat-label">FPS</div>
      </div>
    </div>

    <div class="control-group">
      <label for="preset">Preset</label>
      <select id="preset">
        <option value="infinity" selected>Infinity</option>
        <option value="usa">USA States</option>
        <option value="draw">Draw on canvas</option>
        <option value="circle">Circle</option>
        <option value="heart">Heart</option>
        <option value="star">Star</option>
        <option value="spiral">Spiral</option>
        <option value="text">Text (scanline)</option>
      </select>
    </div>

    <div class="control-group" id="textInputWrap" style="display:none;">
      <label for="textInput">Text</label>
      <input id="textInput" type="text" placeholder="Type something" value="HELLO" />
    </div>

    <div class="control-group">
      <label for="epicycles">Epicycles: <span class="value-display" id="epicyclesValue">80</span></label>
      <input id="epicycles" type="range" min="1" max="500" value="80" />
    </div>

    <div class="control-group">
      <label for="samples">Samples: <span class="value-display" id="samplesValue">256</span></label>
      <input id="samples" type="range" min="10" max="1000" step="10" value="256" />
    </div>

    <div class="control-group">
      <label for="speed">Speed: <span class="value-display" id="speedValue">1.0</span></label>
      <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1" />
    </div>

    <div class="control-group">
      <label for="sort">Sort</label>
      <select id="sort">
        <option value="magnitude">Magnitude</option>
        <option value="frequency">Frequency</option>
      </select>
    </div>

    <div class="control-group">
      <label style="display: flex; align-items: center; gap: 8px;">
        <input id="showOriginal" type="checkbox" checked />
        <span>Original path</span>
      </label>
      <label style="display: flex; align-items: center; gap: 8px;">
        <input id="showCircles" type="checkbox" checked />
        <span>Circles</span>
      </label>
      <label style="display: flex; align-items: center; gap: 8px;">
        <input id="showLines" type="checkbox" checked />
        <span>Lines</span>
      </label>
    </div>

    <div class="button-group">
      <button id="play">Pause</button>
      <button id="clear">Clear Trace</button>
      <button id="capture">Use Current Path</button>
    </div>

    <div class="control-group">
      <label for="scrub">Timeline: <span class="value-display" id="scrubValue">0.00</span></label>
      <input id="scrub" type="range" min="0" max="1" step="0.001" value="0" />
    </div>

    <div class="control-group" style="grid-column: 1 / -1;">
      <div class="tip">Tip: Draw slowly for smoother curves. Text preset uses scanline hatching.</div>
    </div>
  </div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const presetSelect = document.getElementById("preset");
const textInputWrap = document.getElementById("textInputWrap");
const textInput = document.getElementById("textInput");
const epicyclesInput = document.getElementById("epicycles");
const samplesInput = document.getElementById("samples");
const speedInput = document.getElementById("speed");
const sortInput = document.getElementById("sort");
const showOriginalInput = document.getElementById("showOriginal");
const showCirclesInput = document.getElementById("showCircles");
const showLinesInput = document.getElementById("showLines");
const playButton = document.getElementById("play");
const clearButton = document.getElementById("clear");
const captureButton = document.getElementById("capture");
const scrubInput = document.getElementById("scrub");

const statFps = document.getElementById("statFps");
const epicyclesValue = document.getElementById("epicyclesValue");
const samplesValue = document.getElementById("samplesValue");
const speedValue = document.getElementById("speedValue");
const scrubValue = document.getElementById("scrubValue");

let width = 0;
let height = 0;
let center = { x: 0, y: 0 };

let drawPoints = [];
let sourcePoints = [];
let resampled = [];
let fourier = [];
let trace = [];
let time = 0;
let playing = true;
let drawing = false;
let scrubbing = false;
let lastFrame = performance.now();
let fps = 0;
const usaTopoUrl = "https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json";
let usaPath = null;
let usaLoading = false;

function resize() {
  width = canvas.clientWidth;
  height = canvas.clientHeight;
  canvas.width = Math.floor(width * devicePixelRatio);
  canvas.height = Math.floor(height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  center = { x: width / 2, y: height / 2 };
}

function distance(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.hypot(dx, dy);
}

function resample(points, targetCount) {
  if (points.length < 2) return [];
  const distances = [0];
  let total = 0;
  for (let i = 1; i < points.length; i++) {
    total += distance(points[i - 1], points[i]);
    distances.push(total);
  }
  const step = total / targetCount;
  const result = [points[0]];
  let target = step;
  for (let i = 1; i < points.length; i++) {
    while (target <= distances[i]) {
      const t = (target - distances[i - 1]) / (distances[i] - distances[i - 1] || 1);
      result.push({
        x: points[i - 1].x + (points[i].x - points[i - 1].x) * t,
        y: points[i - 1].y + (points[i].y - points[i - 1].y) * t
      });
      target += step;
    }
  }
  return result.length > targetCount ? result.slice(0, targetCount) : result;
}

function centerAndScale(points, targetSize) {
  const bounds = points.reduce(
    (acc, p) => {
      acc.minX = Math.min(acc.minX, p.x);
      acc.maxX = Math.max(acc.maxX, p.x);
      acc.minY = Math.min(acc.minY, p.y);
      acc.maxY = Math.max(acc.maxY, p.y);
      return acc;
    },
    { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }
  );
  const cx = (bounds.minX + bounds.maxX) / 2;
  const cy = (bounds.minY + bounds.maxY) / 2;
  const scale = targetSize / Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY, 1);
  return points.map((p) => ({
    x: (p.x - cx) * scale,
    y: (p.y - cy) * scale
  }));
}

function dft(points) {
  const N = points.length;
  const out = [];
  const twoPi = Math.PI * 2;
  for (let k = 0; k < N; k++) {
    let re = 0;
    let im = 0;
    for (let n = 0; n < N; n++) {
      const phi = (twoPi * k * n) / N;
      const cos = Math.cos(phi);
      const sin = Math.sin(phi);
      re += points[n].x * cos + points[n].y * sin;
      im += points[n].y * cos - points[n].x * sin;
    }
    re /= N;
    im /= N;
    const freq = k <= N / 2 ? k : k - N;
    out.push({
      re,
      im,
      freq,
      amp: Math.hypot(re, im),
      phase: Math.atan2(im, re)
    });
  }
  return out;
}

function buildFourier(points) {
  const coefficients = dft(points);
  return coefficients;
}

function epicycles(x, y, rotation, coeffs, count) {
  let vx = x;
  let vy = y;
  for (let i = 0; i < count; i++) {
    const c = coeffs[i];
    const radius = c.amp;
    const angle = c.freq * time + c.phase + rotation;
    const nx = vx + radius * Math.cos(angle);
    const ny = vy + radius * Math.sin(angle);

    if (showCirclesInput.checked) {
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0, 255, 65, 0.28)";
      ctx.lineWidth = 1.6;
      ctx.arc(vx, vy, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    if (showLinesInput.checked) {
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0, 255, 65, 0.65)";
      ctx.lineWidth = 2;
      ctx.moveTo(vx, vy);
      ctx.lineTo(nx, ny);
      ctx.stroke();
    }

    vx = nx;
    vy = ny;
  }
  return { x: vx, y: vy };
}

function drawTrace() {
  if (trace.length < 2) return;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(0, 255, 65, 0.55)";
  ctx.lineWidth = 3;
  ctx.shadowColor = "rgba(0, 255, 65, 0.5)";
  ctx.shadowBlur = 10;
  ctx.moveTo(trace[0].x, trace[0].y);
  const breakDistance = Math.min(width, height) * 0.25;
  for (let i = 1; i < trace.length; i++) {
    const jump = distance(trace[i - 1], trace[i]);
    if (jump > breakDistance) {
      ctx.moveTo(trace[i].x, trace[i].y);
    } else {
      ctx.lineTo(trace[i].x, trace[i].y);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function drawOriginal() {
  if (!showOriginalInput.checked || resampled.length < 2) return;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(0, 255, 65, 0.15)";
  ctx.lineWidth = 1.2;
  ctx.moveTo(center.x + resampled[0].x, center.y + resampled[0].y);
  for (let i = 1; i < resampled.length; i++) {
    ctx.lineTo(center.x + resampled[i].x, center.y + resampled[i].y);
  }
  ctx.stroke();
}

function updateStats() {
  statFps.textContent = fps.toFixed(0);
  epicyclesValue.textContent = epicyclesInput.value;
  samplesValue.textContent = samplesInput.value;
  speedValue.textContent = parseFloat(speedInput.value).toFixed(1);
  scrubValue.textContent = parseFloat(scrubInput.value).toFixed(2);
}

function render() {
  const now = performance.now();
  fps = 1000 / (now - lastFrame + 0.001);
  lastFrame = now;

  ctx.clearRect(0, 0, width, height);

  drawOriginal();

  if (fourier.length) {
    const count = Math.min(parseInt(epicyclesInput.value, 10), fourier.length);
    const tip = epicycles(center.x, center.y, 0, fourier, count);
    trace.unshift(tip);
    const maxTrace = resampled.length ? resampled.length : 600;
    if (trace.length > maxTrace) trace.pop();
    drawTrace();
    ctx.beginPath();
    ctx.fillStyle = "rgba(0, 255, 65, 0.95)";
    ctx.shadowColor = "rgba(0, 255, 65, 0.9)";
    ctx.shadowBlur = 18;
    ctx.arc(tip.x, tip.y, 4.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    if (!scrubbing && playing) {
      const dt = (Math.PI * 2) / resampled.length;
      time += dt * parseFloat(speedInput.value);
      scrubInput.value = (time % (Math.PI * 2)) / (Math.PI * 2);
    }
  }

  updateStats();
  requestAnimationFrame(render);
}

function useSource(points) {
  sourcePoints = points;
  resampled = resample(points, parseInt(samplesInput.value, 10));
  if (resampled.length < 2) return;
  const sortMode = sortInput.value;
  fourier = buildFourier(resampled);
  if (sortMode === "magnitude") {
    fourier.sort((a, b) => b.amp - a.amp);
  } else {
    fourier.sort((a, b) => a.freq - b.freq);
  }
  trace = [];
  time = 0;
  scrubInput.value = 0;
}

function getPointerPosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: event.clientX - rect.left - center.x,
    y: event.clientY - rect.top - center.y
  };
}

function startDrawing(event) {
  if (presetSelect.value !== "draw") return;
  drawing = true;
  drawPoints = [];
  const point = getPointerPosition(event);
  drawPoints.push(point);
}

function moveDrawing(event) {
  if (!drawing) return;
  const point = getPointerPosition(event);
  const last = drawPoints[drawPoints.length - 1];
  if (!last || distance(point, last) > 2) {
    drawPoints.push(point);
  }
}

function endDrawing() {
  if (!drawing) return;
  drawing = false;
  if (drawPoints.length > 10) {
    useSource(drawPoints);
  }
}

function createCircle(count) {
  const pts = [];
  const radius = Math.min(width, height) * 0.25;
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    pts.push({ x: radius * Math.cos(angle), y: radius * Math.sin(angle) });
  }
  return pts;
}

function createHeart(count) {
  const pts = [];
  for (let i = 0; i < count; i++) {
    const t = (Math.PI * 2 * i) / count;
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
    pts.push({ x: x * 12, y: y * 12 });
  }
  return pts;
}

function createStar(points) {
  const pts = [];
  const outer = 220;
  const inner = 90;
  const spikes = 5;
  for (let i = 0; i <= spikes * 2; i++) {
    const radius = i % 2 === 0 ? outer : inner;
    const angle = (Math.PI * i) / spikes;
    pts.push({ x: radius * Math.cos(angle), y: radius * Math.sin(angle) });
  }
  return resample(pts, points);
}

function createSpiral(count) {
  const pts = [];
  const turns = 4;
  const maxR = 240;
  for (let i = 0; i < count; i++) {
    const t = i / (count - 1);
    const angle = turns * Math.PI * 2 * t;
    const radius = maxR * t;
    pts.push({ x: radius * Math.cos(angle), y: radius * Math.sin(angle) });
  }
  return pts;
}

function createInfinity(count) {
  const pts = [];
  for (let i = 0; i < count; i++) {
    const t = (Math.PI * 2 * i) / count;
    const denom = 1 + Math.pow(Math.sin(t), 2);
    const x = (Math.cos(t) / denom) * 260;
    const y = (Math.sin(t) * Math.cos(t) / denom) * 160;
    pts.push({ x, y });
  }
  return pts;
}

function createTextPath(text) {
  const off = document.createElement("canvas");
  const size = 512;
  off.width = size;
  off.height = size;
  const octx = off.getContext("2d");
  octx.clearRect(0, 0, size, size);
  octx.fillStyle = "white";
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.font = "bold 200px 'Avenir Next', 'Futura', sans-serif";
  octx.fillText(text, size / 2, size / 2);

  const data = octx.getImageData(0, 0, size, size).data;
  const step = 4;
  const pts = [];
  let rowIndex = 0;
  for (let y = 0; y < size; y += step) {
    const row = [];
    for (let x = 0; x < size; x += step) {
      const idx = (y * size + x) * 4 + 3;
      if (data[idx] > 30) {
        row.push({ x, y });
      }
    }
    if (row.length) {
      if (rowIndex % 2 === 1) row.reverse();
      pts.push(...row);
      rowIndex += 1;
    }
  }
  const centered = centerAndScale(pts, Math.min(width, height) * 0.8);
  return centered;
}

function ringArea(ring) {
  let area = 0;
  for (let i = 0; i < ring.length; i++) {
    const a = ring[i];
    const b = ring[(i + 1) % ring.length];
    area += a[0] * b[1] - b[0] * a[1];
  }
  return area * 0.5;
}

function ringCentroid(ring) {
  let cx = 0;
  let cy = 0;
  let area = 0;
  for (let i = 0; i < ring.length; i++) {
    const a = ring[i];
    const b = ring[(i + 1) % ring.length];
    const cross = a[0] * b[1] - b[0] * a[1];
    area += cross;
    cx += (a[0] + b[0]) * cross;
    cy += (a[1] + b[1]) * cross;
  }
  area *= 0.5;
  const factor = area === 0 ? 1 : 1 / (6 * area);
  return { x: cx * factor, y: cy * factor };
}

function pickConusRing(geometry, bbox) {
  const [minLon, minLat, maxLon, maxLat] = bbox;
  let bestRing = null;
  let bestArea = -Infinity;

  const considerRing = (ring) => {
    const centroid = ringCentroid(ring);
    if (
      centroid.x < minLon ||
      centroid.x > maxLon ||
      centroid.y < minLat ||
      centroid.y > maxLat
    ) {
      return;
    }
    const area = Math.abs(ringArea(ring));
    if (area > bestArea) {
      bestArea = area;
      bestRing = ring;
    }
  };

  if (!geometry) return null;
  if (geometry.type === "Polygon") {
    if (geometry.coordinates[0]) considerRing(geometry.coordinates[0]);
  } else if (geometry.type === "MultiPolygon") {
    geometry.coordinates.forEach((polygon) => {
      if (polygon[0]) considerRing(polygon[0]);
    });
  }

  return bestRing;
}

async function loadUsaPreset() {
  if (usaPath) {
    useSource(usaPath);
    return;
  }
  if (usaLoading) return;
  usaLoading = true;
  try {
    const response = await fetch(usaTopoUrl);
    if (!response.ok) throw new Error("Failed to load USA topology.");
    const topo = await response.json();
    if (!window.topojson || !topo.objects || !topo.objects.states) {
      throw new Error("TopoJSON client missing.");
    }
    const bbox = [-125, 24, -66, 50];
    const nation = topojson.merge(topo, topo.objects.states.geometries);
    const ring = nation ? pickConusRing(nation, bbox) : null;
    if (!ring) {
      throw new Error("Unable to find CONUS outline.");
    }
    const projected = ring.map(([lon, lat]) => ({ x: lon, y: -lat }));
    usaPath = centerAndScale(projected, Math.min(width, height) * 0.9);
    samplesInput.value = "512";
    useSource(usaPath);
  } catch (error) {
    console.error(error);
    presetSelect.value = "infinity";
    loadPreset();
  } finally {
    usaLoading = false;
  }
}

function loadPreset() {
  const preset = presetSelect.value;
  textInputWrap.style.display = preset === "text" ? "block" : "none";
  if (preset === "usa") {
    loadUsaPreset();
    return;
  }
  if (preset === "draw") return;

  const count = parseInt(samplesInput.value, 10);
  let points = [];
  if (preset === "circle") points = createCircle(count);
  if (preset === "heart") points = createHeart(count);
  if (preset === "star") points = createStar(count);
  if (preset === "spiral") points = createSpiral(count);
  if (preset === "infinity") points = createInfinity(count);
  if (preset === "text") points = createTextPath(textInput.value || "HI");

  if (points.length) {
    points = centerAndScale(points, Math.min(width, height) * 0.8);
    useSource(points);
  }
}

function clearTrace() {
  trace = [];
  time = 0;
  scrubInput.value = 0;
}

function togglePlay() {
  playing = !playing;
  playButton.textContent = playing ? "Pause" : "Play";
}

function applyCurrentPath() {
  if (resampled.length) {
    useSource(resampled);
  }
}

window.addEventListener("resize", () => {
  resize();
  loadPreset();
});

canvas.addEventListener("pointerdown", (event) => {
  canvas.setPointerCapture(event.pointerId);
  startDrawing(event);
});

canvas.addEventListener("pointermove", moveDrawing);
canvas.addEventListener("pointerup", () => endDrawing());
canvas.addEventListener("pointerleave", () => endDrawing());

presetSelect.addEventListener("change", loadPreset);
textInput.addEventListener("change", loadPreset);

samplesInput.addEventListener("input", () => {
  if (sourcePoints.length) useSource(sourcePoints);
});

sortInput.addEventListener("change", () => {
  if (sourcePoints.length) useSource(sourcePoints);
});

epicyclesInput.addEventListener("input", updateStats);

speedInput.addEventListener("input", updateStats);

playButton.addEventListener("click", togglePlay);
clearButton.addEventListener("click", clearTrace);
captureButton.addEventListener("click", applyCurrentPath);

scrubInput.addEventListener("pointerdown", () => {
  scrubbing = true;
  playing = false;
  playButton.textContent = "Play";
});

scrubInput.addEventListener("pointerup", () => {
  scrubbing = false;
});

scrubInput.addEventListener("input", (event) => {
  const value = parseFloat(event.target.value);
  time = value * Math.PI * 2;
  trace = [];
  updateStats();
});

resize();
loadPreset();
requestAnimationFrame(render);
</script>
</body>
</html>
